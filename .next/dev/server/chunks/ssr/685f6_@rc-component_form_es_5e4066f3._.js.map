{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/FieldContext.js"],"sourcesContent":["import warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nexport const HOOK_MARK = 'RC_FORM_INTERNAL_HOOKS';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst warningFunc = () => {\n  warning(false, 'Can not find FormContext. Please make sure you wrap Field under Form.');\n};\nconst Context = /*#__PURE__*/React.createContext({\n  getFieldValue: warningFunc,\n  getFieldsValue: warningFunc,\n  getFieldError: warningFunc,\n  getFieldWarning: warningFunc,\n  getFieldsError: warningFunc,\n  isFieldsTouched: warningFunc,\n  isFieldTouched: warningFunc,\n  isFieldValidating: warningFunc,\n  isFieldsValidating: warningFunc,\n  resetFields: warningFunc,\n  setFields: warningFunc,\n  setFieldValue: warningFunc,\n  setFieldsValue: warningFunc,\n  validateFields: warningFunc,\n  submit: warningFunc,\n  getInternalHooks: () => {\n    warningFunc();\n    return {\n      dispatch: warningFunc,\n      initEntityValue: warningFunc,\n      registerField: warningFunc,\n      useSubscribe: warningFunc,\n      setInitialValues: warningFunc,\n      destroyForm: warningFunc,\n      setCallbacks: warningFunc,\n      registerWatch: warningFunc,\n      getFields: warningFunc,\n      setValidateMessages: warningFunc,\n      setPreserve: warningFunc,\n      getInitialValue: warningFunc\n    };\n  }\n});\nexport default Context;"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AACO,MAAM,YAAY;AAEzB,8DAA8D;AAC9D,MAAM,cAAc;IAClB,IAAA,6NAAO,EAAC,OAAO;AACjB;AACA,MAAM,UAAU,WAAW,GAAE,8QAAmB,CAAC;IAC/C,eAAe;IACf,gBAAgB;IAChB,eAAe;IACf,iBAAiB;IACjB,gBAAgB;IAChB,iBAAiB;IACjB,gBAAgB;IAChB,mBAAmB;IACnB,oBAAoB;IACpB,aAAa;IACb,WAAW;IACX,eAAe;IACf,gBAAgB;IAChB,gBAAgB;IAChB,QAAQ;IACR,kBAAkB;QAChB;QACA,OAAO;YACL,UAAU;YACV,iBAAiB;YACjB,eAAe;YACf,cAAc;YACd,kBAAkB;YAClB,aAAa;YACb,cAAc;YACd,eAAe;YACf,WAAW;YACX,qBAAqB;YACrB,aAAa;YACb,iBAAiB;QACnB;IACF;AACF;uCACe","ignoreList":[0]}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/ListContext.js"],"sourcesContent":["import * as React from 'react';\nconst ListContext = /*#__PURE__*/React.createContext(null);\nexport default ListContext;"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,cAAc,WAAW,GAAE,8QAAmB,CAAC;uCACtC","ignoreList":[0]}},
    {"offset": {"line": 70, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/utils/typeUtil.js"],"sourcesContent":["export function toArray(value) {\n  if (value === undefined || value === null) {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nexport function isFormInstance(form) {\n  return form && !!form._init;\n}"],"names":[],"mappings":";;;;;;AAAO,SAAS,QAAQ,KAAK;IAC3B,IAAI,UAAU,aAAa,UAAU,MAAM;QACzC,OAAO,EAAE;IACX;IACA,OAAO,MAAM,OAAO,CAAC,SAAS,QAAQ;QAAC;KAAM;AAC/C;AACO,SAAS,eAAe,IAAI;IACjC,OAAO,QAAQ,CAAC,CAAC,KAAK,KAAK;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/utils/messages.js"],"sourcesContent":["const typeTemplate = \"'${name}' is not a valid ${type}\";\nexport const defaultValidateMessages = {\n  default: \"Validation error on field '${name}'\",\n  required: \"'${name}' is required\",\n  enum: \"'${name}' must be one of [${enum}]\",\n  whitespace: \"'${name}' cannot be empty\",\n  date: {\n    format: \"'${name}' is invalid for format date\",\n    parse: \"'${name}' could not be parsed as date\",\n    invalid: \"'${name}' is invalid date\"\n  },\n  types: {\n    string: typeTemplate,\n    method: typeTemplate,\n    array: typeTemplate,\n    object: typeTemplate,\n    number: typeTemplate,\n    date: typeTemplate,\n    boolean: typeTemplate,\n    integer: typeTemplate,\n    float: typeTemplate,\n    regexp: typeTemplate,\n    email: typeTemplate,\n    tel: typeTemplate,\n    url: typeTemplate,\n    hex: typeTemplate\n  },\n  string: {\n    len: \"'${name}' must be exactly ${len} characters\",\n    min: \"'${name}' must be at least ${min} characters\",\n    max: \"'${name}' cannot be longer than ${max} characters\",\n    range: \"'${name}' must be between ${min} and ${max} characters\"\n  },\n  number: {\n    len: \"'${name}' must equal ${len}\",\n    min: \"'${name}' cannot be less than ${min}\",\n    max: \"'${name}' cannot be greater than ${max}\",\n    range: \"'${name}' must be between ${min} and ${max}\"\n  },\n  array: {\n    len: \"'${name}' must be exactly ${len} in length\",\n    min: \"'${name}' cannot be less than ${min} in length\",\n    max: \"'${name}' cannot be greater than ${max} in length\",\n    range: \"'${name}' must be between ${min} and ${max} in length\"\n  },\n  pattern: {\n    mismatch: \"'${name}' does not match pattern ${pattern}\"\n  }\n};"],"names":[],"mappings":";;;;AAAA,MAAM,eAAe;AACd,MAAM,0BAA0B;IACrC,SAAS;IACT,UAAU;IACV,MAAM;IACN,YAAY;IACZ,MAAM;QACJ,QAAQ;QACR,OAAO;QACP,SAAS;IACX;IACA,OAAO;QACL,QAAQ;QACR,QAAQ;QACR,OAAO;QACP,QAAQ;QACR,QAAQ;QACR,MAAM;QACN,SAAS;QACT,SAAS;QACT,OAAO;QACP,QAAQ;QACR,OAAO;QACP,KAAK;QACL,KAAK;QACL,KAAK;IACP;IACA,QAAQ;QACN,KAAK;QACL,KAAK;QACL,KAAK;QACL,OAAO;IACT;IACA,QAAQ;QACN,KAAK;QACL,KAAK;QACL,KAAK;QACL,OAAO;IACT;IACA,OAAO;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,OAAO;IACT;IACA,SAAS;QACP,UAAU;IACZ;AACF","ignoreList":[0]}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/utils/validateUtil.js"],"sourcesContent":["import RawAsyncValidator from '@rc-component/async-validator';\nimport * as React from 'react';\nimport warning from \"@rc-component/util/es/warning\";\nimport { defaultValidateMessages } from \"./messages\";\nimport { merge } from \"@rc-component/util/es/utils/set\";\n\n// Remove incorrect original ts define\nconst AsyncValidator = RawAsyncValidator;\n\n/**\n * Replace with template.\n *   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo\n */\nfunction replaceMessage(template, kv) {\n  return template.replace(/\\\\?\\$\\{\\w+\\}/g, str => {\n    if (str.startsWith('\\\\')) {\n      return str.slice(1);\n    }\n    const key = str.slice(2, -1);\n    return kv[key];\n  });\n}\nconst CODE_LOGIC_ERROR = 'CODE_LOGIC_ERROR';\nasync function validateRule(name, value, rule, options, messageVariables) {\n  const cloneRule = {\n    ...rule\n  };\n\n  // Bug of `async-validator`\n  // https://github.com/react-component/field-form/issues/316\n  // https://github.com/react-component/field-form/issues/313\n  delete cloneRule.ruleIndex;\n\n  // https://github.com/ant-design/ant-design/issues/40497#issuecomment-1422282378\n  AsyncValidator.warning = () => void 0;\n  if (cloneRule.validator) {\n    const originValidator = cloneRule.validator;\n    cloneRule.validator = (...args) => {\n      try {\n        return originValidator(...args);\n      } catch (error) {\n        console.error(error);\n        return Promise.reject(CODE_LOGIC_ERROR);\n      }\n    };\n  }\n\n  // We should special handle array validate\n  let subRuleField = null;\n  if (cloneRule && cloneRule.type === 'array' && cloneRule.defaultField) {\n    subRuleField = cloneRule.defaultField;\n    delete cloneRule.defaultField;\n  }\n  const validator = new AsyncValidator({\n    [name]: [cloneRule]\n  });\n  const messages = merge(defaultValidateMessages, options.validateMessages);\n  validator.messages(messages);\n  let result = [];\n  try {\n    await Promise.resolve(validator.validate({\n      [name]: value\n    }, {\n      ...options\n    }));\n  } catch (errObj) {\n    if (errObj.errors) {\n      result = errObj.errors.map(({\n        message\n      }, index) => {\n        const mergedMessage = message === CODE_LOGIC_ERROR ? messages.default : message;\n        return /*#__PURE__*/React.isValidElement(mergedMessage) ?\n        /*#__PURE__*/\n        // Wrap ReactNode with `key`\n        React.cloneElement(mergedMessage, {\n          key: `error_${index}`\n        }) : mergedMessage;\n      });\n    }\n  }\n  if (!result.length && subRuleField && Array.isArray(value) && value.length > 0) {\n    const subResults = await Promise.all(value.map((subValue, i) => validateRule(`${name}.${i}`, subValue, subRuleField, options, messageVariables)));\n    return subResults.reduce((prev, errors) => [...prev, ...errors], []);\n  }\n\n  // Replace message with variables\n  const kv = {\n    ...rule,\n    name,\n    enum: (rule.enum || []).join(', '),\n    ...messageVariables\n  };\n  const fillVariableResult = result.map(error => {\n    if (typeof error === 'string') {\n      return replaceMessage(error, kv);\n    }\n    return error;\n  });\n  return fillVariableResult;\n}\n\n/**\n * We use `async-validator` to validate the value.\n * But only check one value in a time to avoid namePath validate issue.\n */\nexport function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {\n  const name = namePath.join('.');\n\n  // Fill rule with context\n  const filledRules = rules.map((currentRule, ruleIndex) => {\n    const originValidatorFunc = currentRule.validator;\n    const cloneRule = {\n      ...currentRule,\n      ruleIndex\n    };\n\n    // Replace validator if needed\n    if (originValidatorFunc) {\n      cloneRule.validator = (rule, val, callback) => {\n        let hasPromise = false;\n\n        // Wrap callback only accept when promise not provided\n        const wrappedCallback = (...args) => {\n          // Wait a tick to make sure return type is a promise\n          Promise.resolve().then(() => {\n            warning(!hasPromise, 'Your validator function has already return a promise. `callback` will be ignored.');\n            if (!hasPromise) {\n              callback(...args);\n            }\n          });\n        };\n\n        // Get promise\n        const promise = originValidatorFunc(rule, val, wrappedCallback);\n        hasPromise = promise && typeof promise.then === 'function' && typeof promise.catch === 'function';\n\n        /**\n         * 1. Use promise as the first priority.\n         * 2. If promise not exist, use callback with warning instead\n         */\n        warning(hasPromise, '`callback` is deprecated. Please return a promise instead.');\n        if (hasPromise) {\n          promise.then(() => {\n            callback();\n          }).catch(err => {\n            callback(err || ' ');\n          });\n        }\n      };\n    }\n    return cloneRule;\n  }).sort(({\n    warningOnly: w1,\n    ruleIndex: i1\n  }, {\n    warningOnly: w2,\n    ruleIndex: i2\n  }) => {\n    if (!!w1 === !!w2) {\n      // Let keep origin order\n      return i1 - i2;\n    }\n    if (w1) {\n      return 1;\n    }\n    return -1;\n  });\n\n  // Do validate rules\n  let summaryPromise;\n  if (validateFirst === true) {\n    // >>>>> Validate by serialization\n    summaryPromise = new Promise(async (resolve, reject) => {\n      /* eslint-disable no-await-in-loop */\n      for (let i = 0; i < filledRules.length; i += 1) {\n        const rule = filledRules[i];\n        const errors = await validateRule(name, value, rule, options, messageVariables);\n        if (errors.length) {\n          reject([{\n            errors,\n            rule\n          }]);\n          return;\n        }\n      }\n      /* eslint-enable */\n\n      resolve([]);\n    });\n  } else {\n    // >>>>> Validate by parallel\n    const rulePromises = filledRules.map(rule => validateRule(name, value, rule, options, messageVariables).then(errors => ({\n      errors,\n      rule\n    })));\n    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(errors => {\n      // Always change to rejection for Field to catch\n      return Promise.reject(errors);\n    });\n  }\n\n  // Internal catch error to avoid console error log.\n  summaryPromise.catch(e => e);\n  return summaryPromise;\n}\nasync function finishOnAllFailed(rulePromises) {\n  return Promise.all(rulePromises).then(errorsList => {\n    const errors = [].concat(...errorsList);\n    return errors;\n  });\n}\nasync function finishOnFirstFailed(rulePromises) {\n  let count = 0;\n  return new Promise(resolve => {\n    rulePromises.forEach(promise => {\n      promise.then(ruleError => {\n        if (ruleError.errors.length) {\n          resolve([ruleError]);\n        }\n        count += 1;\n        if (count === rulePromises.length) {\n          resolve([]);\n        }\n      });\n    });\n  });\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,sCAAsC;AACtC,MAAM,iBAAiB,yPAAiB;AAExC;;;CAGC,GACD,SAAS,eAAe,QAAQ,EAAE,EAAE;IAClC,OAAO,SAAS,OAAO,CAAC,iBAAiB,CAAA;QACvC,IAAI,IAAI,UAAU,CAAC,OAAO;YACxB,OAAO,IAAI,KAAK,CAAC;QACnB;QACA,MAAM,MAAM,IAAI,KAAK,CAAC,GAAG,CAAC;QAC1B,OAAO,EAAE,CAAC,IAAI;IAChB;AACF;AACA,MAAM,mBAAmB;AACzB,eAAe,aAAa,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,gBAAgB;IACtE,MAAM,YAAY;QAChB,GAAG,IAAI;IACT;IAEA,2BAA2B;IAC3B,2DAA2D;IAC3D,2DAA2D;IAC3D,OAAO,UAAU,SAAS;IAE1B,gFAAgF;IAChF,eAAe,OAAO,GAAG,IAAM,KAAK;IACpC,IAAI,UAAU,SAAS,EAAE;QACvB,MAAM,kBAAkB,UAAU,SAAS;QAC3C,UAAU,SAAS,GAAG,CAAC,GAAG;YACxB,IAAI;gBACF,OAAO,mBAAmB;YAC5B,EAAE,OAAO,OAAO;gBACd,QAAQ,KAAK,CAAC;gBACd,OAAO,QAAQ,MAAM,CAAC;YACxB;QACF;IACF;IAEA,0CAA0C;IAC1C,IAAI,eAAe;IACnB,IAAI,aAAa,UAAU,IAAI,KAAK,WAAW,UAAU,YAAY,EAAE;QACrE,eAAe,UAAU,YAAY;QACrC,OAAO,UAAU,YAAY;IAC/B;IACA,MAAM,YAAY,IAAI,eAAe;QACnC,CAAC,KAAK,EAAE;YAAC;SAAU;IACrB;IACA,MAAM,WAAW,IAAA,gOAAK,EAAC,uPAAuB,EAAE,QAAQ,gBAAgB;IACxE,UAAU,QAAQ,CAAC;IACnB,IAAI,SAAS,EAAE;IACf,IAAI;QACF,MAAM,QAAQ,OAAO,CAAC,UAAU,QAAQ,CAAC;YACvC,CAAC,KAAK,EAAE;QACV,GAAG;YACD,GAAG,OAAO;QACZ;IACF,EAAE,OAAO,QAAQ;QACf,IAAI,OAAO,MAAM,EAAE;YACjB,SAAS,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,EAC1B,OAAO,EACR,EAAE;gBACD,MAAM,gBAAgB,YAAY,mBAAmB,SAAS,OAAO,GAAG;gBACxE,OAAO,WAAW,GAAE,+QAAoB,CAAC,iBACzC,WAAW,GACX,4BAA4B;gBAC5B,6QAAkB,CAAC,eAAe;oBAChC,KAAK,CAAC,MAAM,EAAE,OAAO;gBACvB,KAAK;YACP;QACF;IACF;IACA,IAAI,CAAC,OAAO,MAAM,IAAI,gBAAgB,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,GAAG,GAAG;QAC9E,MAAM,aAAa,MAAM,QAAQ,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,UAAU,IAAM,aAAa,GAAG,KAAK,CAAC,EAAE,GAAG,EAAE,UAAU,cAAc,SAAS;QAC9H,OAAO,WAAW,MAAM,CAAC,CAAC,MAAM,SAAW;mBAAI;mBAAS;aAAO,EAAE,EAAE;IACrE;IAEA,iCAAiC;IACjC,MAAM,KAAK;QACT,GAAG,IAAI;QACP;QACA,MAAM,CAAC,KAAK,IAAI,IAAI,EAAE,EAAE,IAAI,CAAC;QAC7B,GAAG,gBAAgB;IACrB;IACA,MAAM,qBAAqB,OAAO,GAAG,CAAC,CAAA;QACpC,IAAI,OAAO,UAAU,UAAU;YAC7B,OAAO,eAAe,OAAO;QAC/B;QACA,OAAO;IACT;IACA,OAAO;AACT;AAMO,SAAS,cAAc,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,OAAO,EAAE,aAAa,EAAE,gBAAgB;IAC5F,MAAM,OAAO,SAAS,IAAI,CAAC;IAE3B,yBAAyB;IACzB,MAAM,cAAc,MAAM,GAAG,CAAC,CAAC,aAAa;QAC1C,MAAM,sBAAsB,YAAY,SAAS;QACjD,MAAM,YAAY;YAChB,GAAG,WAAW;YACd;QACF;QAEA,8BAA8B;QAC9B,IAAI,qBAAqB;YACvB,UAAU,SAAS,GAAG,CAAC,MAAM,KAAK;gBAChC,IAAI,aAAa;gBAEjB,sDAAsD;gBACtD,MAAM,kBAAkB,CAAC,GAAG;oBAC1B,oDAAoD;oBACpD,QAAQ,OAAO,GAAG,IAAI,CAAC;wBACrB,IAAA,6NAAO,EAAC,CAAC,YAAY;wBACrB,IAAI,CAAC,YAAY;4BACf,YAAY;wBACd;oBACF;gBACF;gBAEA,cAAc;gBACd,MAAM,UAAU,oBAAoB,MAAM,KAAK;gBAC/C,aAAa,WAAW,OAAO,QAAQ,IAAI,KAAK,cAAc,OAAO,QAAQ,KAAK,KAAK;gBAEvF;;;SAGC,GACD,IAAA,6NAAO,EAAC,YAAY;gBACpB,IAAI,YAAY;oBACd,QAAQ,IAAI,CAAC;wBACX;oBACF,GAAG,KAAK,CAAC,CAAA;wBACP,SAAS,OAAO;oBAClB;gBACF;YACF;QACF;QACA,OAAO;IACT,GAAG,IAAI,CAAC,CAAC,EACP,aAAa,EAAE,EACf,WAAW,EAAE,EACd,EAAE,EACD,aAAa,EAAE,EACf,WAAW,EAAE,EACd;QACC,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC,IAAI;YACjB,wBAAwB;YACxB,OAAO,KAAK;QACd;QACA,IAAI,IAAI;YACN,OAAO;QACT;QACA,OAAO,CAAC;IACV;IAEA,oBAAoB;IACpB,IAAI;IACJ,IAAI,kBAAkB,MAAM;QAC1B,kCAAkC;QAClC,iBAAiB,IAAI,QAAQ,OAAO,SAAS;YAC3C,mCAAmC,GACnC,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,MAAM,EAAE,KAAK,EAAG;gBAC9C,MAAM,OAAO,WAAW,CAAC,EAAE;gBAC3B,MAAM,SAAS,MAAM,aAAa,MAAM,OAAO,MAAM,SAAS;gBAC9D,IAAI,OAAO,MAAM,EAAE;oBACjB,OAAO;wBAAC;4BACN;4BACA;wBACF;qBAAE;oBACF;gBACF;YACF;YACA,iBAAiB,GAEjB,QAAQ,EAAE;QACZ;IACF,OAAO;QACL,6BAA6B;QAC7B,MAAM,eAAe,YAAY,GAAG,CAAC,CAAA,OAAQ,aAAa,MAAM,OAAO,MAAM,SAAS,kBAAkB,IAAI,CAAC,CAAA,SAAU,CAAC;oBACtH;oBACA;gBACF,CAAC;QACD,iBAAiB,CAAC,gBAAgB,oBAAoB,gBAAgB,kBAAkB,aAAa,EAAE,IAAI,CAAC,CAAA;YAC1G,gDAAgD;YAChD,OAAO,QAAQ,MAAM,CAAC;QACxB;IACF;IAEA,mDAAmD;IACnD,eAAe,KAAK,CAAC,CAAA,IAAK;IAC1B,OAAO;AACT;AACA,eAAe,kBAAkB,YAAY;IAC3C,OAAO,QAAQ,GAAG,CAAC,cAAc,IAAI,CAAC,CAAA;QACpC,MAAM,SAAS,EAAE,CAAC,MAAM,IAAI;QAC5B,OAAO;IACT;AACF;AACA,eAAe,oBAAoB,YAAY;IAC7C,IAAI,QAAQ;IACZ,OAAO,IAAI,QAAQ,CAAA;QACjB,aAAa,OAAO,CAAC,CAAA;YACnB,QAAQ,IAAI,CAAC,CAAA;gBACX,IAAI,UAAU,MAAM,CAAC,MAAM,EAAE;oBAC3B,QAAQ;wBAAC;qBAAU;gBACrB;gBACA,SAAS;gBACT,IAAI,UAAU,aAAa,MAAM,EAAE;oBACjC,QAAQ,EAAE;gBACZ;YACF;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/utils/valueUtil.js"],"sourcesContent":["import getValue from \"@rc-component/util/es/utils/get\";\nimport setValue from \"@rc-component/util/es/utils/set\";\nimport { toArray } from \"./typeUtil\";\nexport { getValue, setValue };\n\n/**\n * Convert name to internal supported format.\n * This function should keep since we still thinking if need support like `a.b.c` format.\n * 'a' => ['a']\n * 123 => [123]\n * ['a', 123] => ['a', 123]\n */\nexport function getNamePath(path) {\n  return toArray(path);\n}\n\n/**\n * Create a new store object that contains only the values referenced by\n * the provided list of name paths.\n */\nexport function cloneByNamePathList(store, namePathList) {\n  let newStore = {};\n  namePathList.forEach(namePath => {\n    const value = getValue(store, namePath);\n    newStore = setValue(newStore, namePath, value);\n  });\n  return newStore;\n}\n\n/**\n * Check if `namePathList` includes `namePath`.\n * @param namePathList A list of `InternalNamePath[]`\n * @param namePath Compare `InternalNamePath`\n * @param partialMatch True will make `[a, b]` match `[a, b, c]`\n */\nexport function containsNamePath(namePathList, namePath, partialMatch = false) {\n  return namePathList && namePathList.some(path => matchNamePath(namePath, path, partialMatch));\n}\n\n/**\n * Check if `namePath` is super set or equal of `subNamePath`.\n * @param namePath A list of `InternalNamePath[]`\n * @param subNamePath Compare `InternalNamePath`\n * @param partialMatch Default false. True will make `[a, b]` match `[a, b, c]`\n */\nexport function matchNamePath(namePath, subNamePath, partialMatch = false) {\n  if (!namePath || !subNamePath) {\n    return false;\n  }\n  if (!partialMatch && namePath.length !== subNamePath.length) {\n    return false;\n  }\n  return subNamePath.every((nameUnit, i) => namePath[i] === nameUnit);\n}\n\n// Like `shallowEqual`, but we not check the data which may cause re-render\n\nexport function isSimilar(source, target) {\n  if (source === target) {\n    return true;\n  }\n  if (!source && target || source && !target) {\n    return false;\n  }\n  if (!source || !target || typeof source !== 'object' || typeof target !== 'object') {\n    return false;\n  }\n  const sourceKeys = Object.keys(source);\n  const targetKeys = Object.keys(target);\n  const keys = new Set([...sourceKeys, ...targetKeys]);\n  return [...keys].every(key => {\n    const sourceValue = source[key];\n    const targetValue = target[key];\n    if (typeof sourceValue === 'function' && typeof targetValue === 'function') {\n      return true;\n    }\n    return sourceValue === targetValue;\n  });\n}\nexport function defaultGetValueFromEvent(valuePropName, ...args) {\n  const event = args[0];\n  if (event && event.target && typeof event.target === 'object' && valuePropName in event.target) {\n    return event.target[valuePropName];\n  }\n  return event;\n}\n\n/**\n * Moves an array item from one position in an array to another.\n *\n * Note: This is a pure function so a new array will be returned, instead\n * of altering the array argument.\n *\n * @param array         Array in which to move an item.         (required)\n * @param moveIndex     The index of the item to move.          (required)\n * @param toIndex       The index to move item at moveIndex to. (required)\n */\nexport function move(array, moveIndex, toIndex) {\n  const {\n    length\n  } = array;\n  if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {\n    return array;\n  }\n  const item = array[moveIndex];\n  const diff = moveIndex - toIndex;\n  if (diff > 0) {\n    // move left\n    return [...array.slice(0, toIndex), item, ...array.slice(toIndex, moveIndex), ...array.slice(moveIndex + 1, length)];\n  }\n  if (diff < 0) {\n    // move right\n    return [...array.slice(0, moveIndex), ...array.slice(moveIndex + 1, toIndex + 1), item, ...array.slice(toIndex + 1, length)];\n  }\n  return array;\n}"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;;AAUO,SAAS,YAAY,IAAI;IAC9B,OAAO,IAAA,uOAAO,EAAC;AACjB;AAMO,SAAS,oBAAoB,KAAK,EAAE,YAAY;IACrD,IAAI,WAAW,CAAC;IAChB,aAAa,OAAO,CAAC,CAAA;QACnB,MAAM,QAAQ,IAAA,kOAAQ,EAAC,OAAO;QAC9B,WAAW,IAAA,kOAAQ,EAAC,UAAU,UAAU;IAC1C;IACA,OAAO;AACT;AAQO,SAAS,iBAAiB,YAAY,EAAE,QAAQ,EAAE,eAAe,KAAK;IAC3E,OAAO,gBAAgB,aAAa,IAAI,CAAC,CAAA,OAAQ,cAAc,UAAU,MAAM;AACjF;AAQO,SAAS,cAAc,QAAQ,EAAE,WAAW,EAAE,eAAe,KAAK;IACvE,IAAI,CAAC,YAAY,CAAC,aAAa;QAC7B,OAAO;IACT;IACA,IAAI,CAAC,gBAAgB,SAAS,MAAM,KAAK,YAAY,MAAM,EAAE;QAC3D,OAAO;IACT;IACA,OAAO,YAAY,KAAK,CAAC,CAAC,UAAU,IAAM,QAAQ,CAAC,EAAE,KAAK;AAC5D;AAIO,SAAS,UAAU,MAAM,EAAE,MAAM;IACtC,IAAI,WAAW,QAAQ;QACrB,OAAO;IACT;IACA,IAAI,CAAC,UAAU,UAAU,UAAU,CAAC,QAAQ;QAC1C,OAAO;IACT;IACA,IAAI,CAAC,UAAU,CAAC,UAAU,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;QAClF,OAAO;IACT;IACA,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,MAAM,OAAO,IAAI,IAAI;WAAI;WAAe;KAAW;IACnD,OAAO;WAAI;KAAK,CAAC,KAAK,CAAC,CAAA;QACrB,MAAM,cAAc,MAAM,CAAC,IAAI;QAC/B,MAAM,cAAc,MAAM,CAAC,IAAI;QAC/B,IAAI,OAAO,gBAAgB,cAAc,OAAO,gBAAgB,YAAY;YAC1E,OAAO;QACT;QACA,OAAO,gBAAgB;IACzB;AACF;AACO,SAAS,yBAAyB,aAAa,EAAE,GAAG,IAAI;IAC7D,MAAM,QAAQ,IAAI,CAAC,EAAE;IACrB,IAAI,SAAS,MAAM,MAAM,IAAI,OAAO,MAAM,MAAM,KAAK,YAAY,iBAAiB,MAAM,MAAM,EAAE;QAC9F,OAAO,MAAM,MAAM,CAAC,cAAc;IACpC;IACA,OAAO;AACT;AAYO,SAAS,KAAK,KAAK,EAAE,SAAS,EAAE,OAAO;IAC5C,MAAM,EACJ,MAAM,EACP,GAAG;IACJ,IAAI,YAAY,KAAK,aAAa,UAAU,UAAU,KAAK,WAAW,QAAQ;QAC5E,OAAO;IACT;IACA,MAAM,OAAO,KAAK,CAAC,UAAU;IAC7B,MAAM,OAAO,YAAY;IACzB,IAAI,OAAO,GAAG;QACZ,YAAY;QACZ,OAAO;eAAI,MAAM,KAAK,CAAC,GAAG;YAAU;eAAS,MAAM,KAAK,CAAC,SAAS;eAAe,MAAM,KAAK,CAAC,YAAY,GAAG;SAAQ;IACtH;IACA,IAAI,OAAO,GAAG;QACZ,aAAa;QACb,OAAO;eAAI,MAAM,KAAK,CAAC,GAAG;eAAe,MAAM,KAAK,CAAC,YAAY,GAAG,UAAU;YAAI;eAAS,MAAM,KAAK,CAAC,UAAU,GAAG;SAAQ;IAC9H;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 475, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/Field.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport toChildrenArray from \"@rc-component/util/es/Children/toArray\";\nimport isEqual from \"@rc-component/util/es/isEqual\";\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport ListContext from \"./ListContext\";\nimport { toArray } from \"./utils/typeUtil\";\nimport { validateRules } from \"./utils/validateUtil\";\nimport { containsNamePath, defaultGetValueFromEvent, getNamePath, getValue } from \"./utils/valueUtil\";\nconst EMPTY_ERRORS = [];\nconst EMPTY_WARNINGS = [];\nfunction requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {\n  if (typeof shouldUpdate === 'function') {\n    return shouldUpdate(prev, next, 'source' in info ? {\n      source: info.source\n    } : {});\n  }\n  return prevValue !== nextValue;\n}\n\n// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style\n\n// We use Class instead of Hooks here since it will cost much code by using Hooks.\nclass Field extends React.Component {\n  static contextType = FieldContext;\n  state = {\n    resetCount: 0\n  };\n  cancelRegisterFunc = null;\n  mounted = false;\n\n  /**\n   * Follow state should not management in State since it will async update by React.\n   * This makes first render of form can not get correct state value.\n   */\n  touched = false;\n\n  /**\n   * Mark when touched & validated. Currently only used for `dependencies`.\n   * Note that we do not think field with `initialValue` is dirty\n   * but this will be by `isFieldDirty` func.\n   */\n  dirty = false;\n  validatePromise;\n  prevValidating;\n  errors = EMPTY_ERRORS;\n  warnings = EMPTY_WARNINGS;\n\n  // ============================== Subscriptions ==============================\n  constructor(props) {\n    super(props);\n\n    // Register on init\n    if (props.fieldContext) {\n      const {\n        getInternalHooks\n      } = props.fieldContext;\n      const {\n        initEntityValue\n      } = getInternalHooks(HOOK_MARK);\n      initEntityValue(this);\n    }\n  }\n  componentDidMount() {\n    const {\n      shouldUpdate,\n      fieldContext\n    } = this.props;\n    this.mounted = true;\n\n    // Register on init\n    if (fieldContext) {\n      const {\n        getInternalHooks\n      } = fieldContext;\n      const {\n        registerField\n      } = getInternalHooks(HOOK_MARK);\n      this.cancelRegisterFunc = registerField(this);\n    }\n\n    // One more render for component in case fields not ready\n    if (shouldUpdate === true) {\n      this.reRender();\n    }\n  }\n  componentWillUnmount() {\n    this.cancelRegister();\n    this.triggerMetaEvent(true);\n    this.mounted = false;\n  }\n  cancelRegister = () => {\n    const {\n      preserve,\n      isListField,\n      name\n    } = this.props;\n    if (this.cancelRegisterFunc) {\n      this.cancelRegisterFunc(isListField, preserve, getNamePath(name));\n    }\n    this.cancelRegisterFunc = null;\n  };\n\n  // ================================== Utils ==================================\n  getNamePath = () => {\n    const {\n      name,\n      fieldContext\n    } = this.props;\n    const {\n      prefixName = []\n    } = fieldContext;\n    return name !== undefined ? [...prefixName, ...name] : [];\n  };\n  getRules = () => {\n    const {\n      rules = [],\n      fieldContext\n    } = this.props;\n    return rules.map(rule => {\n      if (typeof rule === 'function') {\n        return rule(fieldContext);\n      }\n      return rule;\n    });\n  };\n  reRender() {\n    if (!this.mounted) return;\n    this.forceUpdate();\n  }\n  refresh = () => {\n    if (!this.mounted) return;\n\n    /**\n     * Clean up current node.\n     */\n    this.setState(({\n      resetCount\n    }) => ({\n      resetCount: resetCount + 1\n    }));\n  };\n\n  // Event should only trigger when meta changed\n  metaCache = null;\n  triggerMetaEvent = destroy => {\n    const {\n      onMetaChange\n    } = this.props;\n    if (onMetaChange) {\n      const meta = {\n        ...this.getMeta(),\n        destroy\n      };\n      if (!isEqual(this.metaCache, meta)) {\n        onMetaChange(meta);\n      }\n      this.metaCache = meta;\n    } else {\n      this.metaCache = null;\n    }\n  };\n\n  // ========================= Field Entity Interfaces =========================\n  // Trigger by store update. Check if need update the component\n  onStoreChange = (prevStore, namePathList, info) => {\n    const {\n      shouldUpdate,\n      dependencies = [],\n      onReset\n    } = this.props;\n    const {\n      store\n    } = info;\n    const namePath = this.getNamePath();\n    const prevValue = this.getValue(prevStore);\n    const curValue = this.getValue(store);\n    const namePathMatch = namePathList && containsNamePath(namePathList, namePath);\n\n    // `setFieldsValue` is a quick access to update related status\n    if (info.type === 'valueUpdate' && info.source === 'external' && !isEqual(prevValue, curValue)) {\n      this.touched = true;\n      this.dirty = true;\n      this.validatePromise = null;\n      this.errors = EMPTY_ERRORS;\n      this.warnings = EMPTY_WARNINGS;\n      this.triggerMetaEvent();\n    }\n    switch (info.type) {\n      case 'reset':\n        if (!namePathList || namePathMatch) {\n          // Clean up state\n          this.touched = false;\n          this.dirty = false;\n          this.validatePromise = undefined;\n          this.errors = EMPTY_ERRORS;\n          this.warnings = EMPTY_WARNINGS;\n          this.triggerMetaEvent();\n          onReset?.();\n          this.refresh();\n          return;\n        }\n        break;\n\n      /**\n       * In case field with `preserve = false` nest deps like:\n       * - A = 1 => show B\n       * - B = 1 => show C\n       * - Reset A, need clean B, C\n       */\n      case 'remove':\n        {\n          if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      case 'setField':\n        {\n          const {\n            data\n          } = info;\n          if (namePathMatch) {\n            if ('touched' in data) {\n              this.touched = data.touched;\n            }\n            if ('validating' in data && !('originRCField' in data)) {\n              this.validatePromise = data.validating ? Promise.resolve([]) : null;\n            }\n            if ('errors' in data) {\n              this.errors = data.errors || EMPTY_ERRORS;\n            }\n            if ('warnings' in data) {\n              this.warnings = data.warnings || EMPTY_WARNINGS;\n            }\n            this.dirty = true;\n            this.triggerMetaEvent();\n            this.reRender();\n            return;\n          } else if ('value' in data && containsNamePath(namePathList, namePath, true)) {\n            // Contains path with value should also check\n            this.reRender();\n            return;\n          }\n\n          // Handle update by `setField` with `shouldUpdate`\n          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      case 'dependenciesUpdate':\n        {\n          /**\n           * Trigger when marked `dependencies` updated. Related fields will all update\n           */\n          const dependencyList = dependencies.map(getNamePath);\n          // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be\n          // emitted earlier and they will work there\n          // If set it may cause unnecessary twice rerendering\n          if (dependencyList.some(dependency => containsNamePath(info.relatedFields, dependency))) {\n            this.reRender();\n            return;\n          }\n          break;\n        }\n      default:\n        // 1. If `namePath` exists in `namePathList`, means it's related value and should update\n        //      For example <List name=\"list\"><Field name={['list', 0]}></List>\n        //      If `namePathList` is [['list']] (List value update), Field should be updated\n        //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated\n        // 2.\n        //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,\n        //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`\n        //       is not provided\n        //   2.2 If `shouldUpdate` provided, use customize logic to update the field\n        //       else to check if value changed\n        if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {\n          this.reRender();\n          return;\n        }\n        break;\n    }\n    if (shouldUpdate === true) {\n      this.reRender();\n    }\n  };\n  validateRules = options => {\n    // We should fixed namePath & value to avoid developer change then by form function\n    const namePath = this.getNamePath();\n    const currentValue = this.getValue();\n    const {\n      triggerName,\n      validateOnly = false\n    } = options || {};\n\n    // Force change to async to avoid rule OOD under renderProps field\n    const rootPromise = Promise.resolve().then(async () => {\n      if (!this.mounted) {\n        return [];\n      }\n      const {\n        validateFirst = false,\n        messageVariables,\n        validateDebounce\n      } = this.props;\n\n      // Start validate\n      let filteredRules = this.getRules();\n      if (triggerName) {\n        filteredRules = filteredRules.filter(rule => rule).filter(rule => {\n          const {\n            validateTrigger\n          } = rule;\n          if (!validateTrigger) {\n            return true;\n          }\n          const triggerList = toArray(validateTrigger);\n          return triggerList.includes(triggerName);\n        });\n      }\n\n      // Wait for debounce. Skip if no `triggerName` since its from `validateFields / submit`\n      if (validateDebounce && triggerName) {\n        await new Promise(resolve => {\n          setTimeout(resolve, validateDebounce);\n        });\n\n        // Skip since out of date\n        if (this.validatePromise !== rootPromise) {\n          return [];\n        }\n      }\n      const promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);\n      promise.catch(e => e).then((ruleErrors = EMPTY_ERRORS) => {\n        if (this.validatePromise === rootPromise) {\n          this.validatePromise = null;\n\n          // Get errors & warnings\n          const nextErrors = [];\n          const nextWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors = EMPTY_ERRORS\n          }) => {\n            if (warningOnly) {\n              nextWarnings.push(...errors);\n            } else {\n              nextErrors.push(...errors);\n            }\n          });\n          this.errors = nextErrors;\n          this.warnings = nextWarnings;\n          this.triggerMetaEvent();\n          this.reRender();\n        }\n      });\n      return promise;\n    });\n    if (validateOnly) {\n      return rootPromise;\n    }\n    this.validatePromise = rootPromise;\n    this.dirty = true;\n    this.errors = EMPTY_ERRORS;\n    this.warnings = EMPTY_WARNINGS;\n    this.triggerMetaEvent();\n\n    // Force trigger re-render since we need sync renderProps with new meta\n    this.reRender();\n    return rootPromise;\n  };\n  isFieldValidating = () => !!this.validatePromise;\n  isFieldTouched = () => this.touched;\n  isFieldDirty = () => {\n    // Touched or validate or has initialValue\n    if (this.dirty || this.props.initialValue !== undefined) {\n      return true;\n    }\n\n    // Form set initialValue\n    const {\n      fieldContext\n    } = this.props;\n    const {\n      getInitialValue\n    } = fieldContext.getInternalHooks(HOOK_MARK);\n    if (getInitialValue(this.getNamePath()) !== undefined) {\n      return true;\n    }\n    return false;\n  };\n  getErrors = () => this.errors;\n  getWarnings = () => this.warnings;\n  isListField = () => this.props.isListField;\n  isList = () => this.props.isList;\n  isPreserve = () => this.props.preserve;\n\n  // ============================= Child Component =============================\n  getMeta = () => {\n    // Make error & validating in cache to save perf\n    this.prevValidating = this.isFieldValidating();\n    const meta = {\n      touched: this.isFieldTouched(),\n      validating: this.prevValidating,\n      errors: this.errors,\n      warnings: this.warnings,\n      name: this.getNamePath(),\n      validated: this.validatePromise === null\n    };\n    return meta;\n  };\n\n  // Only return validate child node. If invalidate, will do nothing about field.\n  getOnlyChild = children => {\n    // Support render props\n    if (typeof children === 'function') {\n      const meta = this.getMeta();\n      return {\n        ...this.getOnlyChild(children(this.getControlled(), meta, this.props.fieldContext)),\n        isFunction: true\n      };\n    }\n\n    // Filed element only\n    const childList = toChildrenArray(children);\n    if (childList.length !== 1 || ! /*#__PURE__*/React.isValidElement(childList[0])) {\n      return {\n        child: childList,\n        isFunction: false\n      };\n    }\n    return {\n      child: childList[0],\n      isFunction: false\n    };\n  };\n\n  // ============================== Field Control ==============================\n  getValue = store => {\n    const {\n      getFieldsValue\n    } = this.props.fieldContext;\n    const namePath = this.getNamePath();\n    return getValue(store || getFieldsValue(true), namePath);\n  };\n  getControlled = (childProps = {}) => {\n    const {\n      name,\n      trigger = 'onChange',\n      validateTrigger,\n      getValueFromEvent,\n      normalize,\n      valuePropName = 'value',\n      getValueProps,\n      fieldContext\n    } = this.props;\n    const mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;\n    const namePath = this.getNamePath();\n    const {\n      getInternalHooks,\n      getFieldsValue\n    } = fieldContext;\n    const {\n      dispatch\n    } = getInternalHooks(HOOK_MARK);\n    const value = this.getValue();\n    const mergedGetValueProps = getValueProps || (val => ({\n      [valuePropName]: val\n    }));\n    const originTriggerFunc = childProps[trigger];\n    const valueProps = name !== undefined ? mergedGetValueProps(value) : {};\n\n    // warning when prop value is function\n    if (process.env.NODE_ENV !== 'production' && valueProps) {\n      Object.keys(valueProps).forEach(key => {\n        warning(typeof valueProps[key] !== 'function', `It's not recommended to generate dynamic function prop by \\`getValueProps\\`. Please pass it to child component directly (prop: ${key})`);\n      });\n    }\n    const control = {\n      ...childProps,\n      ...valueProps\n    };\n\n    // Add trigger\n    control[trigger] = (...args) => {\n      // Mark as touched\n      this.touched = true;\n      this.dirty = true;\n      this.triggerMetaEvent();\n      let newValue;\n      if (getValueFromEvent) {\n        newValue = getValueFromEvent(...args);\n      } else {\n        newValue = defaultGetValueFromEvent(valuePropName, ...args);\n      }\n      if (normalize) {\n        newValue = normalize(newValue, value, getFieldsValue(true));\n      }\n      if (newValue !== value) {\n        dispatch({\n          type: 'updateValue',\n          namePath,\n          value: newValue\n        });\n      }\n      if (originTriggerFunc) {\n        originTriggerFunc(...args);\n      }\n    };\n\n    // Add validateTrigger\n    const validateTriggerList = toArray(mergedValidateTrigger || []);\n    validateTriggerList.forEach(triggerName => {\n      // Wrap additional function of component, so that we can get latest value from store\n      const originTrigger = control[triggerName];\n      control[triggerName] = (...args) => {\n        if (originTrigger) {\n          originTrigger(...args);\n        }\n\n        // Always use latest rules\n        const {\n          rules\n        } = this.props;\n        if (rules && rules.length) {\n          // We dispatch validate to root,\n          // since it will update related data with other field with same name\n          dispatch({\n            type: 'validateField',\n            namePath,\n            triggerName\n          });\n        }\n      };\n    });\n    return control;\n  };\n  render() {\n    const {\n      resetCount\n    } = this.state;\n    const {\n      children\n    } = this.props;\n    const {\n      child,\n      isFunction\n    } = this.getOnlyChild(children);\n\n    // Not need to `cloneElement` since user can handle this in render function self\n    let returnChildNode;\n    if (isFunction) {\n      returnChildNode = child;\n    } else if ( /*#__PURE__*/React.isValidElement(child)) {\n      returnChildNode = /*#__PURE__*/React.cloneElement(child, this.getControlled(child.props));\n    } else {\n      warning(!child, '`children` of Field is not validate ReactElement.');\n      returnChildNode = child;\n    }\n    return /*#__PURE__*/React.createElement(React.Fragment, {\n      key: resetCount\n    }, returnChildNode);\n  }\n}\nfunction WrapperField({\n  name,\n  ...restProps\n}) {\n  const fieldContext = React.useContext(FieldContext);\n  const listContext = React.useContext(ListContext);\n  const namePath = name !== undefined ? getNamePath(name) : undefined;\n  const isMergedListField = restProps.isListField ?? !!listContext;\n  let key = 'keep';\n  if (!isMergedListField) {\n    key = `_${(namePath || []).join('_')}`;\n  }\n\n  // Warning if it's a directly list field.\n  // We can still support multiple level field preserve.\n  if (process.env.NODE_ENV !== 'production' && restProps.preserve === false && isMergedListField && namePath.length <= 1) {\n    warning(false, '`preserve` should not apply on Form.List fields.');\n  }\n  return /*#__PURE__*/React.createElement(Field, _extends({\n    key: key,\n    name: namePath,\n    isListField: isMergedListField\n  }, restProps, {\n    fieldContext: fieldContext\n  }));\n}\nexport default WrapperField;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 978, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/List.js"],"sourcesContent":["import * as React from 'react';\nimport warning from \"@rc-component/util/es/warning\";\nimport FieldContext from \"./FieldContext\";\nimport Field from \"./Field\";\nimport { move, getNamePath } from \"./utils/valueUtil\";\nimport ListContext from \"./ListContext\";\nfunction List({\n  name,\n  initialValue,\n  children,\n  rules,\n  validateTrigger,\n  isListField\n}) {\n  const context = React.useContext(FieldContext);\n  const wrapperListContext = React.useContext(ListContext);\n  const keyRef = React.useRef({\n    keys: [],\n    id: 0\n  });\n  const keyManager = keyRef.current;\n  const prefixName = React.useMemo(() => {\n    const parentPrefixName = getNamePath(context.prefixName) || [];\n    return [...parentPrefixName, ...getNamePath(name)];\n  }, [context.prefixName, name]);\n  const fieldContext = React.useMemo(() => ({\n    ...context,\n    prefixName\n  }), [context, prefixName]);\n\n  // List context\n  const listContext = React.useMemo(() => ({\n    getKey: namePath => {\n      const len = prefixName.length;\n      const pathName = namePath[len];\n      return [keyManager.keys[pathName], namePath.slice(len + 1)];\n    }\n  }), [keyManager, prefixName]);\n\n  // User should not pass `children` as other type.\n  if (typeof children !== 'function') {\n    warning(false, 'Form.List only accepts function as children.');\n    return null;\n  }\n  const shouldUpdate = (prevValue, nextValue, {\n    source\n  }) => {\n    if (source === 'internal') {\n      return false;\n    }\n    return prevValue !== nextValue;\n  };\n  return /*#__PURE__*/React.createElement(ListContext.Provider, {\n    value: listContext\n  }, /*#__PURE__*/React.createElement(FieldContext.Provider, {\n    value: fieldContext\n  }, /*#__PURE__*/React.createElement(Field, {\n    name: [],\n    shouldUpdate: shouldUpdate,\n    rules: rules,\n    validateTrigger: validateTrigger,\n    initialValue: initialValue,\n    isList: true,\n    isListField: isListField ?? !!wrapperListContext\n  }, ({\n    value = [],\n    onChange\n  }, meta) => {\n    const {\n      getFieldValue\n    } = context;\n    const getNewValue = () => {\n      const values = getFieldValue(prefixName || []);\n      return values || [];\n    };\n    /**\n     * Always get latest value in case user update fields by `form` api.\n     */\n    const operations = {\n      add: (defaultValue, index) => {\n        // Mapping keys\n        const newValue = getNewValue();\n        if (index >= 0 && index <= newValue.length) {\n          keyManager.keys = [...keyManager.keys.slice(0, index), keyManager.id, ...keyManager.keys.slice(index)];\n          onChange([...newValue.slice(0, index), defaultValue, ...newValue.slice(index)]);\n        } else {\n          if (process.env.NODE_ENV !== 'production' && (index < 0 || index > newValue.length)) {\n            warning(false, 'The second parameter of the add function should be a valid positive number.');\n          }\n          keyManager.keys = [...keyManager.keys, keyManager.id];\n          onChange([...newValue, defaultValue]);\n        }\n        keyManager.id += 1;\n      },\n      remove: index => {\n        const newValue = getNewValue();\n        const indexSet = new Set(Array.isArray(index) ? index : [index]);\n        if (indexSet.size <= 0) {\n          return;\n        }\n        keyManager.keys = keyManager.keys.filter((_, keysIndex) => !indexSet.has(keysIndex));\n\n        // Trigger store change\n        onChange(newValue.filter((_, valueIndex) => !indexSet.has(valueIndex)));\n      },\n      move(from, to) {\n        if (from === to) {\n          return;\n        }\n        const newValue = getNewValue();\n\n        // Do not handle out of range\n        if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {\n          return;\n        }\n        keyManager.keys = move(keyManager.keys, from, to);\n\n        // Trigger store change\n        onChange(move(newValue, from, to));\n      }\n    };\n    let listValue = value || [];\n    if (!Array.isArray(listValue)) {\n      listValue = [];\n      if (process.env.NODE_ENV !== 'production') {\n        warning(false, `Current value of '${prefixName.join(' > ')}' is not an array type.`);\n      }\n    }\n    return children(listValue.map((__, index) => {\n      let key = keyManager.keys[index];\n      if (key === undefined) {\n        keyManager.keys[index] = keyManager.id;\n        key = keyManager.keys[index];\n        keyManager.id += 1;\n      }\n      return {\n        name: index,\n        key,\n        isListField: true\n      };\n    }), operations, meta);\n  })));\n}\nexport default List;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1147, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/utils/asyncUtil.js"],"sourcesContent":["export function allPromiseFinish(promiseList) {\n  let hasError = false;\n  let count = promiseList.length;\n  const results = [];\n  if (!promiseList.length) {\n    return Promise.resolve([]);\n  }\n  return new Promise((resolve, reject) => {\n    promiseList.forEach((promise, index) => {\n      promise.catch(e => {\n        hasError = true;\n        return e;\n      }).then(result => {\n        count -= 1;\n        results[index] = result;\n        if (count > 0) {\n          return;\n        }\n        if (hasError) {\n          reject(results);\n        }\n        resolve(results);\n      });\n    });\n  });\n}"],"names":[],"mappings":";;;;AAAO,SAAS,iBAAiB,WAAW;IAC1C,IAAI,WAAW;IACf,IAAI,QAAQ,YAAY,MAAM;IAC9B,MAAM,UAAU,EAAE;IAClB,IAAI,CAAC,YAAY,MAAM,EAAE;QACvB,OAAO,QAAQ,OAAO,CAAC,EAAE;IAC3B;IACA,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,YAAY,OAAO,CAAC,CAAC,SAAS;YAC5B,QAAQ,KAAK,CAAC,CAAA;gBACZ,WAAW;gBACX,OAAO;YACT,GAAG,IAAI,CAAC,CAAA;gBACN,SAAS;gBACT,OAAO,CAAC,MAAM,GAAG;gBACjB,IAAI,QAAQ,GAAG;oBACb;gBACF;gBACA,IAAI,UAAU;oBACZ,OAAO;gBACT;gBACA,QAAQ;YACV;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1181, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/utils/NameMap.js"],"sourcesContent":["const SPLIT = '__@field_split__';\n\n/**\n * Convert name path into string to fast the fetch speed of Map.\n */\nfunction normalize(namePath) {\n  return namePath.map(cell => `${typeof cell}:${cell}`)\n  // Magic split\n  .join(SPLIT);\n}\n\n/**\n * NameMap like a `Map` but accepts `string[]` as key.\n */\nclass NameMap {\n  kvs = new Map();\n  set(key, value) {\n    this.kvs.set(normalize(key), value);\n  }\n  get(key) {\n    return this.kvs.get(normalize(key));\n  }\n  getAsPrefix(key) {\n    const normalizedKey = normalize(key);\n    const normalizedPrefix = normalizedKey + SPLIT;\n    const results = [];\n    const current = this.kvs.get(normalizedKey);\n    if (current !== undefined) {\n      results.push(current);\n    }\n    this.kvs.forEach((value, itemNormalizedKey) => {\n      if (itemNormalizedKey.startsWith(normalizedPrefix)) {\n        results.push(value);\n      }\n    });\n    return results;\n  }\n  update(key, updater) {\n    const origin = this.get(key);\n    const next = updater(origin);\n    if (!next) {\n      this.delete(key);\n    } else {\n      this.set(key, next);\n    }\n  }\n  delete(key) {\n    this.kvs.delete(normalize(key));\n  }\n\n  // Since we only use this in test, let simply realize this\n  map(callback) {\n    return [...this.kvs.entries()].map(([key, value]) => {\n      const cells = key.split(SPLIT);\n      return callback({\n        key: cells.map(cell => {\n          const [, type, unit] = cell.match(/^([^:]*):(.*)$/);\n          return type === 'number' ? Number(unit) : unit;\n        }),\n        value\n      });\n    });\n  }\n  toJSON() {\n    const json = {};\n    this.map(({\n      key,\n      value\n    }) => {\n      json[key.join('.')] = value;\n      return null;\n    });\n    return json;\n  }\n}\nexport default NameMap;"],"names":[],"mappings":";;;;AAAA,MAAM,QAAQ;AAEd;;CAEC,GACD,SAAS,UAAU,QAAQ;IACzB,OAAO,SAAS,GAAG,CAAC,CAAA,OAAQ,GAAG,OAAO,KAAK,CAAC,EAAE,MAAM,CACpD,cAAc;KACb,IAAI,CAAC;AACR;AAEA;;CAEC,GACD,MAAM;IACJ,MAAM,IAAI,MAAM;IAChB,IAAI,GAAG,EAAE,KAAK,EAAE;QACd,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU,MAAM;IAC/B;IACA,IAAI,GAAG,EAAE;QACP,OAAO,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,UAAU;IAChC;IACA,YAAY,GAAG,EAAE;QACf,MAAM,gBAAgB,UAAU;QAChC,MAAM,mBAAmB,gBAAgB;QACzC,MAAM,UAAU,EAAE;QAClB,MAAM,UAAU,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;QAC7B,IAAI,YAAY,WAAW;YACzB,QAAQ,IAAI,CAAC;QACf;QACA,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC,OAAO;YACvB,IAAI,kBAAkB,UAAU,CAAC,mBAAmB;gBAClD,QAAQ,IAAI,CAAC;YACf;QACF;QACA,OAAO;IACT;IACA,OAAO,GAAG,EAAE,OAAO,EAAE;QACnB,MAAM,SAAS,IAAI,CAAC,GAAG,CAAC;QACxB,MAAM,OAAO,QAAQ;QACrB,IAAI,CAAC,MAAM;YACT,IAAI,CAAC,MAAM,CAAC;QACd,OAAO;YACL,IAAI,CAAC,GAAG,CAAC,KAAK;QAChB;IACF;IACA,OAAO,GAAG,EAAE;QACV,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU;IAC5B;IAEA,0DAA0D;IAC1D,IAAI,QAAQ,EAAE;QACZ,OAAO;eAAI,IAAI,CAAC,GAAG,CAAC,OAAO;SAAG,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,MAAM;YAC9C,MAAM,QAAQ,IAAI,KAAK,CAAC;YACxB,OAAO,SAAS;gBACd,KAAK,MAAM,GAAG,CAAC,CAAA;oBACb,MAAM,GAAG,MAAM,KAAK,GAAG,KAAK,KAAK,CAAC;oBAClC,OAAO,SAAS,WAAW,OAAO,QAAQ;gBAC5C;gBACA;YACF;QACF;IACF;IACA,SAAS;QACP,MAAM,OAAO,CAAC;QACd,IAAI,CAAC,GAAG,CAAC,CAAC,EACR,GAAG,EACH,KAAK,EACN;YACC,IAAI,CAAC,IAAI,IAAI,CAAC,KAAK,GAAG;YACtB,OAAO;QACT;QACA,OAAO;IACT;AACF;uCACe","ignoreList":[0]}},
    {"offset": {"line": 1258, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/hooks/useNotifyWatch.js"],"sourcesContent":["import { matchNamePath } from \"../utils/valueUtil\";\n/**\n * Call action with delay in macro task.\n */\nconst macroTask = fn => {\n  const channel = new MessageChannel();\n  channel.port1.onmessage = fn;\n  channel.port2.postMessage(null);\n};\nexport default class WatcherCenter {\n  namePathList = [];\n  taskId = 0;\n  watcherList = new Set();\n  form;\n  constructor(form) {\n    this.form = form;\n  }\n  register(callback) {\n    this.watcherList.add(callback);\n    return () => {\n      this.watcherList.delete(callback);\n    };\n  }\n  notify(namePath) {\n    // Insert with deduplication\n    namePath.forEach(path => {\n      if (this.namePathList.every(exist => !matchNamePath(exist, path))) {\n        this.namePathList.push(path);\n      }\n    });\n    this.doBatch();\n  }\n  doBatch() {\n    this.taskId += 1;\n    const currentId = this.taskId;\n    macroTask(() => {\n      if (currentId === this.taskId && this.watcherList.size) {\n        const formInst = this.form.getForm();\n        const values = formInst.getFieldsValue();\n        const allValues = formInst.getFieldsValue(true);\n        this.watcherList.forEach(callback => {\n          callback(values, allValues, this.namePathList);\n        });\n        this.namePathList = [];\n      }\n    });\n  }\n}"],"names":[],"mappings":";;;;AAAA;;AACA;;CAEC,GACD,MAAM,YAAY,CAAA;IAChB,MAAM,UAAU,IAAI;IACpB,QAAQ,KAAK,CAAC,SAAS,GAAG;IAC1B,QAAQ,KAAK,CAAC,WAAW,CAAC;AAC5B;AACe,MAAM;IACnB,eAAe,EAAE,CAAC;IAClB,SAAS,EAAE;IACX,cAAc,IAAI,MAAM;IACxB,KAAK;IACL,YAAY,IAAI,CAAE;QAChB,IAAI,CAAC,IAAI,GAAG;IACd;IACA,SAAS,QAAQ,EAAE;QACjB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;QACrB,OAAO;YACL,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;QAC1B;IACF;IACA,OAAO,QAAQ,EAAE;QACf,4BAA4B;QAC5B,SAAS,OAAO,CAAC,CAAA;YACf,IAAI,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAA,QAAS,CAAC,IAAA,8PAAa,EAAC,OAAO,QAAQ;gBACjE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;YACzB;QACF;QACA,IAAI,CAAC,OAAO;IACd;IACA,UAAU;QACR,IAAI,CAAC,MAAM,IAAI;QACf,MAAM,YAAY,IAAI,CAAC,MAAM;QAC7B,UAAU;YACR,IAAI,cAAc,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE;gBACtD,MAAM,WAAW,IAAI,CAAC,IAAI,CAAC,OAAO;gBAClC,MAAM,SAAS,SAAS,cAAc;gBACtC,MAAM,YAAY,SAAS,cAAc,CAAC;gBAC1C,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,CAAA;oBACvB,SAAS,QAAQ,WAAW,IAAI,CAAC,YAAY;gBAC/C;gBACA,IAAI,CAAC,YAAY,GAAG,EAAE;YACxB;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1314, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/hooks/useForm.js"],"sourcesContent":["import { merge } from \"@rc-component/util/es/utils/set\";\nimport { mergeWith } from '@rc-component/util';\nimport warning from \"@rc-component/util/es/warning\";\nimport * as React from 'react';\nimport { HOOK_MARK } from \"../FieldContext\";\nimport { allPromiseFinish } from \"../utils/asyncUtil\";\nimport { defaultValidateMessages } from \"../utils/messages\";\nimport NameMap from \"../utils/NameMap\";\nimport { cloneByNamePathList, containsNamePath, getNamePath, getValue, matchNamePath, setValue } from \"../utils/valueUtil\";\nimport WatcherCenter from \"./useNotifyWatch\";\nexport class FormStore {\n  formHooked = false;\n  forceRootUpdate;\n  subscribable = true;\n  store = {};\n  fieldEntities = [];\n  initialValues = {};\n  callbacks = {};\n  validateMessages = null;\n  preserve = null;\n  lastValidatePromise = null;\n  watcherCenter = new WatcherCenter(this);\n  constructor(forceRootUpdate) {\n    this.forceRootUpdate = forceRootUpdate;\n  }\n  getForm = () => ({\n    getFieldValue: this.getFieldValue,\n    getFieldsValue: this.getFieldsValue,\n    getFieldError: this.getFieldError,\n    getFieldWarning: this.getFieldWarning,\n    getFieldsError: this.getFieldsError,\n    isFieldsTouched: this.isFieldsTouched,\n    isFieldTouched: this.isFieldTouched,\n    isFieldValidating: this.isFieldValidating,\n    isFieldsValidating: this.isFieldsValidating,\n    resetFields: this.resetFields,\n    setFields: this.setFields,\n    setFieldValue: this.setFieldValue,\n    setFieldsValue: this.setFieldsValue,\n    validateFields: this.validateFields,\n    submit: this.submit,\n    _init: true,\n    getInternalHooks: this.getInternalHooks\n  });\n\n  // ======================== Internal Hooks ========================\n  getInternalHooks = key => {\n    if (key === HOOK_MARK) {\n      this.formHooked = true;\n      return {\n        dispatch: this.dispatch,\n        initEntityValue: this.initEntityValue,\n        registerField: this.registerField,\n        useSubscribe: this.useSubscribe,\n        setInitialValues: this.setInitialValues,\n        destroyForm: this.destroyForm,\n        setCallbacks: this.setCallbacks,\n        setValidateMessages: this.setValidateMessages,\n        getFields: this.getFields,\n        setPreserve: this.setPreserve,\n        getInitialValue: this.getInitialValue,\n        registerWatch: this.registerWatch\n      };\n    }\n    warning(false, '`getInternalHooks` is internal usage. Should not call directly.');\n    return null;\n  };\n  useSubscribe = subscribable => {\n    this.subscribable = subscribable;\n  };\n\n  /**\n   * Record prev Form unmount fieldEntities which config preserve false.\n   * This need to be refill with initialValues instead of store value.\n   */\n  prevWithoutPreserves = null;\n\n  /**\n   * First time `setInitialValues` should update store with initial value\n   */\n  setInitialValues = (initialValues, init) => {\n    this.initialValues = initialValues || {};\n    if (init) {\n      let nextStore = merge(initialValues, this.store);\n\n      // We will take consider prev form unmount fields.\n      // When the field is not `preserve`, we need fill this with initialValues instead of store.\n      // eslint-disable-next-line array-callback-return\n      this.prevWithoutPreserves?.map(({\n        key: namePath\n      }) => {\n        nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));\n      });\n      this.prevWithoutPreserves = null;\n      this.updateStore(nextStore);\n    }\n  };\n  destroyForm = clearOnDestroy => {\n    if (clearOnDestroy) {\n      // destroy form reset store\n      this.updateStore({});\n    } else {\n      // Fill preserve fields\n      const prevWithoutPreserves = new NameMap();\n      this.getFieldEntities(true).forEach(entity => {\n        if (!this.isMergedPreserve(entity.isPreserve())) {\n          prevWithoutPreserves.set(entity.getNamePath(), true);\n        }\n      });\n      this.prevWithoutPreserves = prevWithoutPreserves;\n    }\n  };\n  getInitialValue = namePath => {\n    const initValue = getValue(this.initialValues, namePath);\n\n    // Not cloneDeep when without `namePath`\n    return namePath.length ? merge(initValue) : initValue;\n  };\n  setCallbacks = callbacks => {\n    this.callbacks = callbacks;\n  };\n  setValidateMessages = validateMessages => {\n    this.validateMessages = validateMessages;\n  };\n  setPreserve = preserve => {\n    this.preserve = preserve;\n  };\n\n  // ============================= Watch ============================\n  registerWatch = callback => {\n    return this.watcherCenter.register(callback);\n  };\n  notifyWatch = (namePath = []) => {\n    this.watcherCenter.notify(namePath);\n  };\n\n  // ========================== Dev Warning =========================\n  timeoutId = null;\n  warningUnhooked = () => {\n    if (process.env.NODE_ENV !== 'production' && !this.timeoutId && typeof window !== 'undefined') {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        if (!this.formHooked) {\n          warning(false, 'Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?');\n        }\n      });\n    }\n  };\n\n  // ============================ Store =============================\n  updateStore = nextStore => {\n    this.store = nextStore;\n  };\n\n  // ============================ Fields ============================\n  /**\n   * Get registered field entities.\n   * @param pure Only return field which has a `name`. Default: false\n   */\n  getFieldEntities = (pure = false) => {\n    if (!pure) {\n      return this.fieldEntities;\n    }\n    return this.fieldEntities.filter(field => field.getNamePath().length);\n  };\n\n  /**\n   * Get a map of registered field entities with their name path as the key.\n   * @param pure Only include fields which have a `name`. Default: false\n   * @returns A NameMap containing field entities indexed by their name paths\n   */\n  getFieldsMap = (pure = false) => {\n    const cache = new NameMap();\n    this.getFieldEntities(pure).forEach(field => {\n      const namePath = field.getNamePath();\n      cache.set(namePath, field);\n    });\n    return cache;\n  };\n\n  /**\n   * Get field entities based on a list of name paths.\n   * @param nameList - Array of name paths to search for. If not provided, returns all field entities with names.\n   * @param includesSubNamePath - Whether to include fields that have the given name path as a prefix.\n   */\n  getFieldEntitiesForNamePathList = (nameList, includesSubNamePath = false) => {\n    if (!nameList) {\n      return this.getFieldEntities(true);\n    }\n    const cache = this.getFieldsMap(true);\n    if (!includesSubNamePath) {\n      return nameList.map(name => {\n        const namePath = getNamePath(name);\n        return cache.get(namePath) || {\n          INVALIDATE_NAME_PATH: getNamePath(name)\n        };\n      });\n    }\n    return nameList.flatMap(name => {\n      const namePath = getNamePath(name);\n      const fields = cache.getAsPrefix(namePath);\n      if (fields.length) {\n        return fields;\n      }\n      return [{\n        INVALIDATE_NAME_PATH: namePath\n      }];\n    });\n  };\n  getFieldsValue = (nameList, filterFunc) => {\n    this.warningUnhooked();\n\n    // Fill args\n    let mergedNameList;\n    let mergedFilterFunc;\n    if (nameList === true || Array.isArray(nameList)) {\n      mergedNameList = nameList;\n      mergedFilterFunc = filterFunc;\n    } else if (nameList && typeof nameList === 'object') {\n      mergedFilterFunc = nameList.filter;\n    }\n    if (mergedNameList === true && !mergedFilterFunc) {\n      return this.store;\n    }\n    const fieldEntities = this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null, true);\n    const filteredNameList = [];\n    const listNamePaths = [];\n    fieldEntities.forEach(entity => {\n      const namePath = entity.INVALIDATE_NAME_PATH || entity.getNamePath();\n\n      // Ignore when it's a list item and not specific the namePath,\n      // since parent field is already take in count\n      if (entity.isList?.()) {\n        listNamePaths.push(namePath);\n        return;\n      }\n      if (!mergedFilterFunc) {\n        filteredNameList.push(namePath);\n      } else {\n        const meta = 'getMeta' in entity ? entity.getMeta() : null;\n        if (mergedFilterFunc(meta)) {\n          filteredNameList.push(namePath);\n        }\n      }\n    });\n    let mergedValues = cloneByNamePathList(this.store, filteredNameList.map(getNamePath));\n\n    // We need fill the list as [] if Form.List is empty\n    listNamePaths.forEach(namePath => {\n      if (!getValue(mergedValues, namePath)) {\n        mergedValues = setValue(mergedValues, namePath, []);\n      }\n    });\n    return mergedValues;\n  };\n  getFieldValue = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    return getValue(this.store, namePath);\n  };\n  getFieldsError = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntitiesForNamePathList(nameList);\n    return fieldEntities.map((entity, index) => {\n      if (entity && !entity.INVALIDATE_NAME_PATH) {\n        return {\n          name: entity.getNamePath(),\n          errors: entity.getErrors(),\n          warnings: entity.getWarnings()\n        };\n      }\n      return {\n        name: getNamePath(nameList[index]),\n        errors: [],\n        warnings: []\n      };\n    });\n  };\n  getFieldError = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.errors;\n  };\n  getFieldWarning = name => {\n    this.warningUnhooked();\n    const namePath = getNamePath(name);\n    const fieldError = this.getFieldsError([namePath])[0];\n    return fieldError.warnings;\n  };\n  isFieldsTouched = (...args) => {\n    this.warningUnhooked();\n    const [arg0, arg1] = args;\n    let namePathList;\n    let isAllFieldsTouched = false;\n    if (args.length === 0) {\n      namePathList = null;\n    } else if (args.length === 1) {\n      if (Array.isArray(arg0)) {\n        namePathList = arg0.map(getNamePath);\n        isAllFieldsTouched = false;\n      } else {\n        namePathList = null;\n        isAllFieldsTouched = arg0;\n      }\n    } else {\n      namePathList = arg0.map(getNamePath);\n      isAllFieldsTouched = arg1;\n    }\n    const fieldEntities = this.getFieldEntities(true);\n    const isFieldTouched = field => field.isFieldTouched();\n\n    // ===== Will get fully compare when not config namePathList =====\n    if (!namePathList) {\n      return isAllFieldsTouched ? fieldEntities.every(entity => isFieldTouched(entity) || entity.isList()) : fieldEntities.some(isFieldTouched);\n    }\n\n    // Generate a nest tree for validate\n    const map = new NameMap();\n    namePathList.forEach(shortNamePath => {\n      map.set(shortNamePath, []);\n    });\n    fieldEntities.forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Find matched entity and put into list\n      namePathList.forEach(shortNamePath => {\n        if (shortNamePath.every((nameUnit, i) => fieldNamePath[i] === nameUnit)) {\n          map.update(shortNamePath, list => [...list, field]);\n        }\n      });\n    });\n\n    // Check if NameMap value is touched\n    const isNamePathListTouched = entities => entities.some(isFieldTouched);\n    const namePathListEntities = map.map(({\n      value\n    }) => value);\n    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);\n  };\n  isFieldTouched = name => {\n    this.warningUnhooked();\n    return this.isFieldsTouched([name]);\n  };\n  isFieldsValidating = nameList => {\n    this.warningUnhooked();\n    const fieldEntities = this.getFieldEntities();\n    if (!nameList) {\n      return fieldEntities.some(testField => testField.isFieldValidating());\n    }\n    const namePathList = nameList.map(getNamePath);\n    return fieldEntities.some(testField => {\n      const fieldNamePath = testField.getNamePath();\n      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();\n    });\n  };\n  isFieldValidating = name => {\n    this.warningUnhooked();\n    return this.isFieldsValidating([name]);\n  };\n\n  /**\n   * Reset Field with field `initialValue` prop.\n   * Can pass `entities` or `namePathList` or just nothing.\n   */\n  resetWithFieldInitialValue = (info = {}) => {\n    // Create cache\n    const cache = new NameMap();\n    const fieldEntities = this.getFieldEntities(true);\n    fieldEntities.forEach(field => {\n      const {\n        initialValue\n      } = field.props;\n      const namePath = field.getNamePath();\n\n      // Record only if has `initialValue`\n      if (initialValue !== undefined) {\n        const records = cache.get(namePath) || new Set();\n        records.add({\n          entity: field,\n          value: initialValue\n        });\n        cache.set(namePath, records);\n      }\n    });\n\n    // Reset\n    const resetWithFields = entities => {\n      entities.forEach(field => {\n        const {\n          initialValue\n        } = field.props;\n        if (initialValue !== undefined) {\n          const namePath = field.getNamePath();\n          const formInitialValue = this.getInitialValue(namePath);\n          if (formInitialValue !== undefined) {\n            // Warning if conflict with form initialValues and do not modify value\n            warning(false, `Form already set 'initialValues' with path '${namePath.join('.')}'. Field can not overwrite it.`);\n          } else {\n            const records = cache.get(namePath);\n            if (records && records.size > 1) {\n              // Warning if multiple field set `initialValue`and do not modify value\n              warning(false, `Multiple Field with path '${namePath.join('.')}' set 'initialValue'. Can not decide which one to pick.`);\n            } else if (records) {\n              const originValue = this.getFieldValue(namePath);\n              const isListField = field.isListField();\n\n              // Set `initialValue`\n              if (!isListField && (!info.skipExist || originValue === undefined)) {\n                this.updateStore(setValue(this.store, namePath, [...records][0].value));\n              }\n            }\n          }\n        }\n      });\n    };\n    let requiredFieldEntities;\n    if (info.entities) {\n      requiredFieldEntities = info.entities;\n    } else if (info.namePathList) {\n      requiredFieldEntities = [];\n      info.namePathList.forEach(namePath => {\n        const records = cache.get(namePath);\n        if (records) {\n          requiredFieldEntities.push(...[...records].map(r => r.entity));\n        }\n      });\n    } else {\n      requiredFieldEntities = fieldEntities;\n    }\n    resetWithFields(requiredFieldEntities);\n  };\n  resetFields = nameList => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (!nameList) {\n      this.updateStore(merge(this.initialValues));\n      this.resetWithFieldInitialValue();\n      this.notifyObservers(prevStore, null, {\n        type: 'reset'\n      });\n      this.notifyWatch();\n      return;\n    }\n\n    // Reset by `nameList`\n    const namePathList = nameList.map(getNamePath);\n    namePathList.forEach(namePath => {\n      const initialValue = this.getInitialValue(namePath);\n      this.updateStore(setValue(this.store, namePath, initialValue));\n    });\n    this.resetWithFieldInitialValue({\n      namePathList\n    });\n    this.notifyObservers(prevStore, namePathList, {\n      type: 'reset'\n    });\n    this.notifyWatch(namePathList);\n  };\n  setFields = fields => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    const namePathList = [];\n    fields.forEach(fieldData => {\n      const {\n        name,\n        ...data\n      } = fieldData;\n      const namePath = getNamePath(name);\n      namePathList.push(namePath);\n\n      // Value\n      if ('value' in data) {\n        this.updateStore(setValue(this.store, namePath, data.value));\n      }\n      this.notifyObservers(prevStore, [namePath], {\n        type: 'setField',\n        data: fieldData\n      });\n    });\n    this.notifyWatch(namePathList);\n  };\n  getFields = () => {\n    const entities = this.getFieldEntities(true);\n    const fields = entities.map(field => {\n      const namePath = field.getNamePath();\n      const meta = field.getMeta();\n      const fieldData = {\n        ...meta,\n        name: namePath,\n        value: this.getFieldValue(namePath)\n      };\n      Object.defineProperty(fieldData, 'originRCField', {\n        value: true\n      });\n      return fieldData;\n    });\n    return fields;\n  };\n\n  // =========================== Observer ===========================\n  /**\n   * This only trigger when a field is on constructor to avoid we get initialValue too late\n   */\n  initEntityValue = entity => {\n    const {\n      initialValue\n    } = entity.props;\n    if (initialValue !== undefined) {\n      const namePath = entity.getNamePath();\n      const prevValue = getValue(this.store, namePath);\n      if (prevValue === undefined) {\n        this.updateStore(setValue(this.store, namePath, initialValue));\n      }\n    }\n  };\n  isMergedPreserve = fieldPreserve => {\n    const mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : this.preserve;\n    return mergedPreserve ?? true;\n  };\n  registerField = entity => {\n    this.fieldEntities.push(entity);\n    const namePath = entity.getNamePath();\n    this.notifyWatch([namePath]);\n\n    // Set initial values\n    if (entity.props.initialValue !== undefined) {\n      const prevStore = this.store;\n      this.resetWithFieldInitialValue({\n        entities: [entity],\n        skipExist: true\n      });\n      this.notifyObservers(prevStore, [entity.getNamePath()], {\n        type: 'valueUpdate',\n        source: 'internal'\n      });\n    }\n\n    // un-register field callback\n    return (isListField, preserve, subNamePath = []) => {\n      this.fieldEntities = this.fieldEntities.filter(item => item !== entity);\n\n      // Clean up store value if not preserve\n      if (!this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {\n        const defaultValue = isListField ? undefined : this.getInitialValue(namePath);\n        if (namePath.length && this.getFieldValue(namePath) !== defaultValue && this.fieldEntities.every(field =>\n        // Only reset when no namePath exist\n        !matchNamePath(field.getNamePath(), namePath))) {\n          const prevStore = this.store;\n          this.updateStore(setValue(prevStore, namePath, defaultValue, true));\n\n          // Notify that field is unmount\n          this.notifyObservers(prevStore, [namePath], {\n            type: 'remove'\n          });\n\n          // Dependencies update\n          this.triggerDependenciesUpdate(prevStore, namePath);\n        }\n      }\n      this.notifyWatch([namePath]);\n    };\n  };\n  dispatch = action => {\n    switch (action.type) {\n      case 'updateValue':\n        {\n          const {\n            namePath,\n            value\n          } = action;\n          this.updateValue(namePath, value);\n          break;\n        }\n      case 'validateField':\n        {\n          const {\n            namePath,\n            triggerName\n          } = action;\n          this.validateFields([namePath], {\n            triggerName\n          });\n          break;\n        }\n      default:\n      // Currently we don't have other action. Do nothing.\n    }\n  };\n  notifyObservers = (prevStore, namePathList, info) => {\n    if (this.subscribable) {\n      const mergedInfo = {\n        ...info,\n        store: this.getFieldsValue(true)\n      };\n      this.getFieldEntities().forEach(({\n        onStoreChange\n      }) => {\n        onStoreChange(prevStore, namePathList, mergedInfo);\n      });\n    } else {\n      this.forceRootUpdate();\n    }\n  };\n\n  /**\n   * Notify dependencies children with parent update\n   * We need delay to trigger validate in case Field is under render props\n   */\n  triggerDependenciesUpdate = (prevStore, namePath) => {\n    const childrenFields = this.getDependencyChildrenFields(namePath);\n    if (childrenFields.length) {\n      this.validateFields(childrenFields);\n    }\n    this.notifyObservers(prevStore, childrenFields, {\n      type: 'dependenciesUpdate',\n      relatedFields: [namePath, ...childrenFields]\n    });\n    return childrenFields;\n  };\n  updateValue = (name, value) => {\n    const namePath = getNamePath(name);\n    const prevStore = this.store;\n    this.updateStore(setValue(this.store, namePath, value));\n    this.notifyObservers(prevStore, [namePath], {\n      type: 'valueUpdate',\n      source: 'internal'\n    });\n    this.notifyWatch([namePath]);\n\n    // Dependencies update\n    const childrenFields = this.triggerDependenciesUpdate(prevStore, namePath);\n\n    // trigger callback function\n    const {\n      onValuesChange\n    } = this.callbacks;\n    if (onValuesChange) {\n      const fieldEntity = this.getFieldsMap(true).get(namePath);\n      const changedValues = cloneByNamePathList(this.store, [namePath]);\n      const allValues = this.getFieldsValue();\n      // Merge changedValues into allValues to ensure allValues contains the latest changes\n      const mergedAllValues = mergeWith([allValues, changedValues], {\n        // When value is array, it means trigger by Form.List which should replace directly\n        prepareArray: current => fieldEntity?.isList() ? [] : [...(current || [])]\n      });\n      onValuesChange(changedValues, mergedAllValues);\n    }\n    this.triggerOnFieldsChange([namePath, ...childrenFields]);\n  };\n\n  // Let all child Field get update.\n  setFieldsValue = store => {\n    this.warningUnhooked();\n    const prevStore = this.store;\n    if (store) {\n      const nextStore = merge(this.store, store);\n      this.updateStore(nextStore);\n    }\n    this.notifyObservers(prevStore, null, {\n      type: 'valueUpdate',\n      source: 'external'\n    });\n    this.notifyWatch();\n  };\n  setFieldValue = (name, value) => {\n    this.setFields([{\n      name,\n      value,\n      errors: [],\n      warnings: [],\n      touched: true\n    }]);\n  };\n  getDependencyChildrenFields = rootNamePath => {\n    const children = new Set();\n    const childrenFields = [];\n    const dependencies2fields = new NameMap();\n\n    /**\n     * Generate maps\n     * Can use cache to save perf if user report performance issue with this\n     */\n    this.getFieldEntities().forEach(field => {\n      const {\n        dependencies\n      } = field.props;\n      (dependencies || []).forEach(dependency => {\n        const dependencyNamePath = getNamePath(dependency);\n        dependencies2fields.update(dependencyNamePath, (fields = new Set()) => {\n          fields.add(field);\n          return fields;\n        });\n      });\n    });\n    const fillChildren = namePath => {\n      const fields = dependencies2fields.get(namePath) || new Set();\n      fields.forEach(field => {\n        if (!children.has(field)) {\n          children.add(field);\n          const fieldNamePath = field.getNamePath();\n          if (field.isFieldDirty() && fieldNamePath.length) {\n            childrenFields.push(fieldNamePath);\n            fillChildren(fieldNamePath);\n          }\n        }\n      });\n    };\n    fillChildren(rootNamePath);\n    return childrenFields;\n  };\n  triggerOnFieldsChange = (namePathList, filedErrors) => {\n    const {\n      onFieldsChange\n    } = this.callbacks;\n    if (onFieldsChange) {\n      const fields = this.getFields();\n\n      /**\n       * Fill errors since `fields` may be replaced by controlled fields\n       */\n      if (filedErrors) {\n        const cache = new NameMap();\n        filedErrors.forEach(({\n          name,\n          errors\n        }) => {\n          cache.set(name, errors);\n        });\n        fields.forEach(field => {\n          // eslint-disable-next-line no-param-reassign\n          field.errors = cache.get(field.name) || field.errors;\n        });\n      }\n      const changedFields = fields.filter(({\n        name: fieldName\n      }) => containsNamePath(namePathList, fieldName));\n      if (changedFields.length) {\n        onFieldsChange(changedFields, fields);\n      }\n    }\n  };\n\n  // =========================== Validate ===========================\n  validateFields = (arg1, arg2) => {\n    this.warningUnhooked();\n    let nameList;\n    let options;\n    if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {\n      nameList = arg1;\n      options = arg2;\n    } else {\n      options = arg1;\n    }\n    const provideNameList = !!nameList;\n    const namePathList = provideNameList ? nameList.map(getNamePath) : [];\n    // Same namePathList, but does not include Form.List name\n    const finalValueNamePathList = [...namePathList];\n\n    // Collect result in promise list\n    const promiseList = [];\n\n    // We temp save the path which need trigger for `onFieldsChange`\n    const TMP_SPLIT = String(Date.now());\n    const validateNamePathList = new Set();\n    const {\n      recursive,\n      dirty\n    } = options || {};\n    this.getFieldEntities(true).forEach(field => {\n      const fieldNamePath = field.getNamePath();\n\n      // Add field if not provide `nameList`\n      if (!provideNameList) {\n        if (\n        // If is field, pass directly\n        !field.isList() ||\n        // If is list, do not add if already exist sub field in the namePathList\n        !namePathList.some(name => matchNamePath(name, fieldNamePath, true))) {\n          finalValueNamePathList.push(fieldNamePath);\n        }\n        namePathList.push(fieldNamePath);\n      }\n\n      // Skip if without rule\n      if (!field.props.rules || !field.props.rules.length) {\n        return;\n      }\n\n      // Skip if only validate dirty field\n      if (dirty && !field.isFieldDirty()) {\n        return;\n      }\n      validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));\n\n      // Add field validate rule in to promise list\n      if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {\n        const promise = field.validateRules({\n          validateMessages: {\n            ...defaultValidateMessages,\n            ...this.validateMessages\n          },\n          ...options\n        });\n\n        // Wrap promise with field\n        promiseList.push(promise.then(() => ({\n          name: fieldNamePath,\n          errors: [],\n          warnings: []\n        })).catch(ruleErrors => {\n          const mergedErrors = [];\n          const mergedWarnings = [];\n          ruleErrors.forEach?.(({\n            rule: {\n              warningOnly\n            },\n            errors\n          }) => {\n            if (warningOnly) {\n              mergedWarnings.push(...errors);\n            } else {\n              mergedErrors.push(...errors);\n            }\n          });\n          if (mergedErrors.length) {\n            return Promise.reject({\n              name: fieldNamePath,\n              errors: mergedErrors,\n              warnings: mergedWarnings\n            });\n          }\n          return {\n            name: fieldNamePath,\n            errors: mergedErrors,\n            warnings: mergedWarnings\n          };\n        }));\n      }\n    });\n    const summaryPromise = allPromiseFinish(promiseList);\n    this.lastValidatePromise = summaryPromise;\n\n    // Notify fields with rule that validate has finished and need update\n    summaryPromise.catch(results => results).then(results => {\n      const resultNamePathList = results.map(({\n        name\n      }) => name);\n      this.notifyObservers(this.store, resultNamePathList, {\n        type: 'validateFinish'\n      });\n      this.triggerOnFieldsChange(resultNamePathList, results);\n    });\n    const returnPromise = summaryPromise.then(() => {\n      if (this.lastValidatePromise === summaryPromise) {\n        return Promise.resolve(this.getFieldsValue(finalValueNamePathList));\n      }\n      return Promise.reject([]);\n    }).catch(results => {\n      const errorList = results.filter(result => result && result.errors.length);\n      const errorMessage = errorList[0]?.errors?.[0];\n      return Promise.reject({\n        message: errorMessage,\n        values: this.getFieldsValue(namePathList),\n        errorFields: errorList,\n        outOfDate: this.lastValidatePromise !== summaryPromise\n      });\n    });\n\n    // Do not throw in console\n    returnPromise.catch(e => e);\n\n    // `validating` changed. Trigger `onFieldsChange`\n    const triggerNamePathList = namePathList.filter(namePath => validateNamePathList.has(namePath.join(TMP_SPLIT)));\n    this.triggerOnFieldsChange(triggerNamePathList);\n    return returnPromise;\n  };\n\n  // ============================ Submit ============================\n  submit = () => {\n    this.warningUnhooked();\n    this.validateFields().then(values => {\n      const {\n        onFinish\n      } = this.callbacks;\n      if (onFinish) {\n        try {\n          onFinish(values);\n        } catch (err) {\n          // Should print error if user `onFinish` callback failed\n          console.error(err);\n        }\n      }\n    }).catch(e => {\n      const {\n        onFinishFailed\n      } = this.callbacks;\n      if (onFinishFailed) {\n        onFinishFailed(e);\n      }\n    });\n  };\n}\nfunction useForm(form) {\n  const formRef = React.useRef(null);\n  const [, forceUpdate] = React.useState({});\n\n  // Create singleton FormStore\n  if (!formRef.current) {\n    if (form) {\n      formRef.current = form;\n    } else {\n      // Create a new FormStore if not provided\n      const forceReRender = () => {\n        forceUpdate({});\n      };\n      const formStore = new FormStore(forceReRender);\n      formRef.current = formStore.getForm();\n    }\n  }\n  return [formRef.current];\n}\nexport default useForm;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2198, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/FormContext.js"],"sourcesContent":["import * as React from 'react';\nconst FormContext = /*#__PURE__*/React.createContext({\n  triggerFormChange: () => {},\n  triggerFormFinish: () => {},\n  registerForm: () => {},\n  unregisterForm: () => {}\n});\nconst FormProvider = ({\n  validateMessages,\n  onFormChange,\n  onFormFinish,\n  children\n}) => {\n  const formContext = React.useContext(FormContext);\n  const formsRef = React.useRef({});\n  return /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: {\n      ...formContext,\n      validateMessages: {\n        ...formContext.validateMessages,\n        ...validateMessages\n      },\n      // =========================================================\n      // =                  Global Form Control                  =\n      // =========================================================\n      triggerFormChange: (name, changedFields) => {\n        if (onFormChange) {\n          onFormChange(name, {\n            changedFields,\n            forms: formsRef.current\n          });\n        }\n        formContext.triggerFormChange(name, changedFields);\n      },\n      triggerFormFinish: (name, values) => {\n        if (onFormFinish) {\n          onFormFinish(name, {\n            values,\n            forms: formsRef.current\n          });\n        }\n        formContext.triggerFormFinish(name, values);\n      },\n      registerForm: (name, form) => {\n        if (name) {\n          formsRef.current = {\n            ...formsRef.current,\n            [name]: form\n          };\n        }\n        formContext.registerForm(name, form);\n      },\n      unregisterForm: name => {\n        const newForms = {\n          ...formsRef.current\n        };\n        delete newForms[name];\n        formsRef.current = newForms;\n        formContext.unregisterForm(name);\n      }\n    }\n  }, children);\n};\nexport { FormProvider };\nexport default FormContext;"],"names":[],"mappings":";;;;;;AAAA;;AACA,MAAM,cAAc,WAAW,GAAE,8QAAmB,CAAC;IACnD,mBAAmB,KAAO;IAC1B,mBAAmB,KAAO;IAC1B,cAAc,KAAO;IACrB,gBAAgB,KAAO;AACzB;AACA,MAAM,eAAe,CAAC,EACpB,gBAAgB,EAChB,YAAY,EACZ,YAAY,EACZ,QAAQ,EACT;IACC,MAAM,cAAc,2QAAgB,CAAC;IACrC,MAAM,WAAW,uQAAY,CAAC,CAAC;IAC/B,OAAO,WAAW,GAAE,8QAAmB,CAAC,YAAY,QAAQ,EAAE;QAC5D,OAAO;YACL,GAAG,WAAW;YACd,kBAAkB;gBAChB,GAAG,YAAY,gBAAgB;gBAC/B,GAAG,gBAAgB;YACrB;YACA,4DAA4D;YAC5D,4DAA4D;YAC5D,4DAA4D;YAC5D,mBAAmB,CAAC,MAAM;gBACxB,IAAI,cAAc;oBAChB,aAAa,MAAM;wBACjB;wBACA,OAAO,SAAS,OAAO;oBACzB;gBACF;gBACA,YAAY,iBAAiB,CAAC,MAAM;YACtC;YACA,mBAAmB,CAAC,MAAM;gBACxB,IAAI,cAAc;oBAChB,aAAa,MAAM;wBACjB;wBACA,OAAO,SAAS,OAAO;oBACzB;gBACF;gBACA,YAAY,iBAAiB,CAAC,MAAM;YACtC;YACA,cAAc,CAAC,MAAM;gBACnB,IAAI,MAAM;oBACR,SAAS,OAAO,GAAG;wBACjB,GAAG,SAAS,OAAO;wBACnB,CAAC,KAAK,EAAE;oBACV;gBACF;gBACA,YAAY,YAAY,CAAC,MAAM;YACjC;YACA,gBAAgB,CAAA;gBACd,MAAM,WAAW;oBACf,GAAG,SAAS,OAAO;gBACrB;gBACA,OAAO,QAAQ,CAAC,KAAK;gBACrB,SAAS,OAAO,GAAG;gBACnB,YAAY,cAAc,CAAC;YAC7B;QACF;IACF,GAAG;AACL;;uCAEe","ignoreList":[0]}},
    {"offset": {"line": 2269, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/Form.js"],"sourcesContent":["function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport * as React from 'react';\nimport useForm from \"./hooks/useForm\";\nimport FieldContext, { HOOK_MARK } from \"./FieldContext\";\nimport FormContext from \"./FormContext\";\nimport { isSimilar } from \"./utils/valueUtil\";\nimport ListContext from \"./ListContext\";\nconst Form = ({\n  name,\n  initialValues,\n  fields,\n  form,\n  preserve,\n  children,\n  component: Component = 'form',\n  validateMessages,\n  validateTrigger = 'onChange',\n  onValuesChange,\n  onFieldsChange,\n  onFinish,\n  onFinishFailed,\n  clearOnDestroy,\n  ...restProps\n}, ref) => {\n  const nativeElementRef = React.useRef(null);\n  const formContext = React.useContext(FormContext);\n\n  // We customize handle event since Context will makes all the consumer re-render:\n  // https://reactjs.org/docs/context.html#contextprovider\n  const [formInstance] = useForm(form);\n  const {\n    useSubscribe,\n    setInitialValues,\n    setCallbacks,\n    setValidateMessages,\n    setPreserve,\n    destroyForm\n  } = formInstance.getInternalHooks(HOOK_MARK);\n\n  // Pass ref with form instance\n  React.useImperativeHandle(ref, () => ({\n    ...formInstance,\n    nativeElement: nativeElementRef.current\n  }));\n\n  // Register form into Context\n  React.useEffect(() => {\n    formContext.registerForm(name, formInstance);\n    return () => {\n      formContext.unregisterForm(name);\n    };\n  }, [formContext, formInstance, name]);\n\n  // Pass props to store\n  setValidateMessages({\n    ...formContext.validateMessages,\n    ...validateMessages\n  });\n  setCallbacks({\n    onValuesChange,\n    onFieldsChange: (changedFields, ...rest) => {\n      formContext.triggerFormChange(name, changedFields);\n      if (onFieldsChange) {\n        onFieldsChange(changedFields, ...rest);\n      }\n    },\n    onFinish: values => {\n      formContext.triggerFormFinish(name, values);\n      if (onFinish) {\n        onFinish(values);\n      }\n    },\n    onFinishFailed\n  });\n  setPreserve(preserve);\n\n  // Set initial value, init store value when first mount\n  const mountRef = React.useRef(null);\n  setInitialValues(initialValues, !mountRef.current);\n  if (!mountRef.current) {\n    mountRef.current = true;\n  }\n\n  // ========================== Unmount ===========================\n  React.useEffect(() => () => destroyForm(clearOnDestroy),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n\n  // Prepare children by `children` type\n  let childrenNode;\n  const childrenRenderProps = typeof children === 'function';\n  if (childrenRenderProps) {\n    const values = formInstance.getFieldsValue(true);\n    childrenNode = children(values, formInstance);\n  } else {\n    childrenNode = children;\n  }\n\n  // Not use subscribe when using render props\n  useSubscribe(!childrenRenderProps);\n\n  // Listen if fields provided. We use ref to save prev data here to avoid additional render\n  const prevFieldsRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {\n      formInstance.setFields(fields || []);\n    }\n    prevFieldsRef.current = fields;\n  }, [fields, formInstance]);\n\n  // =========================== Render ===========================\n  const formContextValue = React.useMemo(() => ({\n    ...formInstance,\n    validateTrigger\n  }), [formInstance, validateTrigger]);\n  const wrapperNode = /*#__PURE__*/React.createElement(ListContext.Provider, {\n    value: null\n  }, /*#__PURE__*/React.createElement(FieldContext.Provider, {\n    value: formContextValue\n  }, childrenNode));\n  if (Component === false) {\n    return wrapperNode;\n  }\n  return /*#__PURE__*/React.createElement(Component, _extends({}, restProps, {\n    ref: nativeElementRef,\n    onSubmit: event => {\n      event.preventDefault();\n      event.stopPropagation();\n      formInstance.submit();\n    },\n    onReset: event => {\n      event.preventDefault();\n      formInstance.resetFields();\n      restProps.onReset?.(event);\n    }\n  }), wrapperNode);\n};\nexport default Form;"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2400, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/hooks/useWatch.js"],"sourcesContent":["import warning from \"@rc-component/util/es/warning\";\nimport { useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport FieldContext, { HOOK_MARK } from \"../FieldContext\";\nimport { isFormInstance } from \"../utils/typeUtil\";\nimport { getNamePath, getValue } from \"../utils/valueUtil\";\nimport { useEvent } from '@rc-component/util';\nexport function stringify(value) {\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return Math.random();\n  }\n}\n\n// ------- selector type -------\n\n// ------- selector type end -------\n\nfunction useWatch(...args) {\n  const [dependencies, _form = {}] = args;\n  const options = isFormInstance(_form) ? {\n    form: _form\n  } : _form;\n  const form = options.form;\n  const [value, setValue] = useState(() => typeof dependencies === 'function' ? dependencies({}) : undefined);\n  const valueStr = useMemo(() => stringify(value), [value]);\n  const valueStrRef = useRef(valueStr);\n  valueStrRef.current = valueStr;\n  const fieldContext = useContext(FieldContext);\n  const formInstance = form || fieldContext;\n  const isValidForm = formInstance && formInstance._init;\n\n  // Warning if not exist form instance\n  if (process.env.NODE_ENV !== 'production') {\n    warning(args.length === 2 ? form ? isValidForm : true : isValidForm, 'useWatch requires a form instance since it can not auto detect from context.');\n  }\n\n  // ============================== Form ==============================\n  const {\n    getFieldsValue,\n    getInternalHooks\n  } = formInstance;\n  const {\n    registerWatch\n  } = getInternalHooks(HOOK_MARK);\n\n  // ============================= Update =============================\n  const triggerUpdate = useEvent((values, allValues) => {\n    const watchValue = options.preserve ? allValues ?? getFieldsValue(true) : values ?? getFieldsValue();\n    const nextValue = typeof dependencies === 'function' ? dependencies(watchValue) : getValue(watchValue, getNamePath(dependencies));\n    if (stringify(value) !== stringify(nextValue)) {\n      setValue(nextValue);\n    }\n  });\n\n  // ============================= Effect =============================\n  const flattenDeps = typeof dependencies === 'function' ? dependencies : JSON.stringify(dependencies);\n\n  // Deps changed\n  useEffect(() => {\n    // Skip if not exist form instance\n    if (!isValidForm) {\n      return;\n    }\n    triggerUpdate();\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isValidForm, flattenDeps]);\n\n  // Value changed\n  useEffect(() => {\n    // Skip if not exist form instance\n    if (!isValidForm) {\n      return;\n    }\n    const cancelRegister = registerWatch((values, allValues) => {\n      triggerUpdate(values, allValues);\n    });\n    return cancelRegister;\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isValidForm]);\n  return value;\n}\nexport default useWatch;"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;;;;;;;AACO,SAAS,UAAU,KAAK;IAC7B,IAAI;QACF,OAAO,KAAK,SAAS,CAAC;IACxB,EAAE,OAAM;QACN,OAAO,KAAK,MAAM;IACpB;AACF;AAEA,gCAAgC;AAEhC,oCAAoC;AAEpC,SAAS,SAAS,GAAG,IAAI;IACvB,MAAM,CAAC,cAAc,QAAQ,CAAC,CAAC,CAAC,GAAG;IACnC,MAAM,UAAU,IAAA,8OAAc,EAAC,SAAS;QACtC,MAAM;IACR,IAAI;IACJ,MAAM,OAAO,QAAQ,IAAI;IACzB,MAAM,CAAC,OAAO,SAAS,GAAG,IAAA,yQAAQ,EAAC,IAAM,OAAO,iBAAiB,aAAa,aAAa,CAAC,KAAK;IACjG,MAAM,WAAW,IAAA,wQAAO,EAAC,IAAM,UAAU,QAAQ;QAAC;KAAM;IACxD,MAAM,cAAc,IAAA,uQAAM,EAAC;IAC3B,YAAY,OAAO,GAAG;IACtB,MAAM,eAAe,IAAA,2QAAU,EAAC,kOAAY;IAC5C,MAAM,eAAe,QAAQ;IAC7B,MAAM,cAAc,gBAAgB,aAAa,KAAK;IAEtD,qCAAqC;IACrC,wCAA2C;QACzC,IAAA,6NAAO,EAAC,KAAK,MAAM,KAAK,IAAI,OAAO,cAAc,OAAO,aAAa;IACvE;IAEA,qEAAqE;IACrE,MAAM,EACJ,cAAc,EACd,gBAAgB,EACjB,GAAG;IACJ,MAAM,EACJ,aAAa,EACd,GAAG,iBAAiB,oOAAS;IAE9B,qEAAqE;IACrE,MAAM,gBAAgB,IAAA,+QAAQ,EAAC,CAAC,QAAQ;QACtC,MAAM,aAAa,QAAQ,QAAQ,GAAG,aAAa,eAAe,QAAQ,UAAU;QACpF,MAAM,YAAY,OAAO,iBAAiB,aAAa,aAAa,cAAc,IAAA,0QAAQ,EAAC,YAAY,IAAA,4PAAW,EAAC;QACnH,IAAI,UAAU,WAAW,UAAU,YAAY;YAC7C,SAAS;QACX;IACF;IAEA,qEAAqE;IACrE,MAAM,cAAc,OAAO,iBAAiB,aAAa,eAAe,KAAK,SAAS,CAAC;IAEvF,eAAe;IACf,IAAA,0QAAS,EAAC;QACR,kCAAkC;QAClC,IAAI,CAAC,aAAa;YAChB;QACF;QACA;IAEA,uDAAuD;IACzD,GAAG;QAAC;QAAa;KAAY;IAE7B,gBAAgB;IAChB,IAAA,0QAAS,EAAC;QACR,kCAAkC;QAClC,IAAI,CAAC,aAAa;YAChB;QACF;QACA,MAAM,iBAAiB,cAAc,CAAC,QAAQ;YAC5C,cAAc,QAAQ;QACxB;QACA,OAAO;IAEP,uDAAuD;IACzD,GAAG;QAAC;KAAY;IAChB,OAAO;AACT;uCACe","ignoreList":[0]}},
    {"offset": {"line": 2494, "column": 0}, "map": {"version":3,"sources":["file:///Users/warathepdav/Documents/sample/nextzy-spinner/frontend/node_modules/%40rc-component/form/es/index.js"],"sourcesContent":["import * as React from 'react';\nimport Field from \"./Field\";\nimport List from \"./List\";\nimport useForm from \"./hooks/useForm\";\nimport FieldForm from \"./Form\";\nimport { FormProvider } from \"./FormContext\";\nimport FieldContext from \"./FieldContext\";\nimport ListContext from \"./ListContext\";\nimport useWatch from \"./hooks/useWatch\";\nconst InternalForm = /*#__PURE__*/React.forwardRef(FieldForm);\nconst RefForm = InternalForm;\nRefForm.FormProvider = FormProvider;\nRefForm.Field = Field;\nRefForm.List = List;\nRefForm.useForm = useForm;\nRefForm.useWatch = useWatch;\nexport { Field, List, useForm, FormProvider, FieldContext, ListContext, useWatch };\nexport default RefForm;"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AACA,MAAM,eAAe,WAAW,GAAE,2QAAgB,CAAC,0NAAS;AAC5D,MAAM,UAAU;AAChB,QAAQ,YAAY,GAAG,sOAAY;AACnC,QAAQ,KAAK,GAAG,2NAAK;AACrB,QAAQ,IAAI,GAAG,0NAAI;AACnB,QAAQ,OAAO,GAAG,sOAAO;AACzB,QAAQ,QAAQ,GAAG,uOAAQ;;uCAEZ","ignoreList":[0]}}]
}